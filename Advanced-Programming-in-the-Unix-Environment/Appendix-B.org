** Appendix B. Miscellaneous Source Code


*** B.1. Our Header File


Most programs in the text include the header =apue.h=, shown in [[file:part0036.xhtml#app02fig01][Figure B.1]]. It defines constants (such as =MAXLINE=) and prototypes for our own functions.



--------------

/*
Â * Our own header, to be included before all standard system headers.
Â */
#ifndef _APUE_H
#define _APUE_H

#define _POSIX_C_SOURCE 200809L

#if defined(SOLARIS)Â Â Â Â Â Â Â Â /* Solaris 10 */
#define _XOPEN_SOURCE 600
#else
#define _XOPEN_SOURCE 700
#endif

#include <sys/types.h>Â Â Â Â Â Â /* some systems still require this */
#include <sys/stat.h>
#include <sys/termios.h>Â Â Â Â /* for winsize */
#if defined(MACOS) || !defined(TIOCGWINSZ)
#include <sys/ioctl.h>
#endif

#include <stdio.h>Â Â Â Â Â Â /* for convenience */
#include <stdlib.h>Â Â Â Â Â /* for convenience */
#include <stddef.h>Â Â Â Â Â /* for offsetof */
#include <string.h>Â Â Â Â Â /* for convenience */
#include <unistd.h>Â Â Â Â Â /* for convenience */
#include <signal.h>Â Â Â Â Â /* for SIG_ERR */

#define MAXLINE 4096Â Â Â Â Â Â Â Â Â Â Â Â /* max line length */

/*
Â * Default file access permissions for new files.
Â */
#define FILE_MODEÂ Â Â (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)

/*
Â * Default permissions for new directories.
Â */
#define DIR_MODEÂ Â Â Â (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

typedef voidÂ Â Â Â Sigfunc(int);Â Â Â /* for signal handlers */

#define min(a,b)Â Â Â Â ((a) < (b) ? (a) : (b))
#define max(a,b)Â Â Â Â ((a) > (b) ? (a) : (b))

/*
Â * Prototypes for our own functions.
Â */
charÂ Â Â Â *path_alloc(size_t *);Â Â Â Â Â Â Â Â Â Â Â Â Â Â /* Figure 2.16 */
longÂ Â Â Â Â open_max(void);Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â /* Figure 2.17 */

int set_cloexec(int);Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â /* Figure 13.9 */
voidÂ Â Â Â clr_fl(int, int);
voidÂ Â Â Â set_fl(int, int);Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â /* Figure 3.12 */

voidÂ Â Â Â pr_exit(int);Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â /* Figure 8.5 */

voidÂ Â Â Â pr_mask(const char *);Â Â Â Â Â Â Â Â Â Â Â Â Â Â /* Figure 10.14 */
Sigfunc *signal_intr(int, Sigfunc *);Â Â Â Â Â Â Â /* Figure 10.19 */

voidÂ Â Â Â Â daemonize(const char *);Â Â Â Â Â Â Â Â Â Â Â /* Figure 13.1 */

voidÂ Â Â Â Â sleep_us(unsigned int);Â Â Â Â Â Â Â Â Â Â Â Â /* Exercise 14.5 */
ssize_tÂ Â readn(int, void *, size_t);Â Â Â Â Â Â Â Â /* Figure 14.24 */
ssize_tÂ Â writen(int, const void *, size_t); /* Figure 14.24 */

intÂ Â Â Â Â Â fd_pipe(int *);Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â /* Figure 17.2 */
intÂ Â Â Â Â Â recv_fd(int, ssize_t (*func)(int,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const void *, size_t));Â Â Â Â /* Figure 17.14 */
intÂ Â Â Â Â Â send_fd(int, int);Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â /* Figure 17.13 */
intÂ Â Â Â Â Â send_err(int, int,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const char *);Â Â Â Â Â Â Â Â Â Â Â Â /* Figure 17.12 */

intÂ Â Â Â Â Â serv_listen(const char *);Â Â Â Â Â Â Â Â Â /* Figure 17.8 */
intÂ Â Â Â Â Â serv_accept(int, uid_t *);Â Â Â Â Â Â Â Â Â /* Figure 17.9 */
intÂ Â Â Â Â Â cli_conn(const char *);Â Â Â Â Â Â Â Â Â Â Â Â /* Figure 17.10 */
intÂ Â Â Â Â Â buf_args(char *, int (*func)(int,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â char **));Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â /* Figure 17.23 */

intÂ Â Â Â Â Â tty_cbreak(int);Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â /* Figure 18.20 */
intÂ Â Â Â Â Â tty_raw(int);Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â /* Figure 18.20 */
intÂ Â Â Â Â Â tty_reset(int);Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â /* Figure 18.20 */
voidÂ Â Â Â Â tty_atexit(void);Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â /* Figure 18.20 */
struct termiosÂ Â *tty_termios(void);Â Â Â Â Â Â Â Â Â /* Figure 18.20 */

intÂ Â Â Â Â Â ptym_open(char *, int);Â Â Â Â Â Â Â Â Â Â Â Â /* Figure 19.9 */
intÂ Â Â Â Â Â ptys_open(char *);Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â /* Figure 19.9 */
#ifdef TIOCGWINSZ
pid_tÂ Â Â pty_fork(int *, char *, int, const struct termios *,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const struct winsize *);Â Â Â /* Figure 19.10 */
#endif

intÂ Â Â Â Â lock_reg(int, int, int, off_t, int, off_t); /* Figure 14.5 */

#define read_lock(fd, offset, whence, len) 
Â Â Â Â Â Â Â Â Â Â Â Â lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) 
Â Â Â Â Â Â Â Â Â Â Â Â lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) 
Â Â Â Â Â Â Â Â Â Â Â Â lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) 
Â Â Â Â Â Â Â Â Â Â Â Â lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) 
Â Â Â Â Â Â Â Â Â Â Â Â lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

pid_tÂ Â Â lock_test(int, int, off_t, int, off_t);Â Â Â Â Â /* Figure 14.6 */

#define is_read_lockable(fd, offset, whence, len) 
Â Â Â Â Â Â Â Â Â Â Â Â (lock_test((fd), F_RDLCK, (offset), (whence), (len)) == 0)
#define is_write_lockable(fd, offset, whence, len) 
Â Â Â Â Â Â Â Â Â Â Â Â (lock_test((fd), F_WRLCK, (offset), (whence), (len)) == 0)

voidÂ Â Â Â err_msg(const char *, ...);Â Â Â Â Â Â Â Â Â /* Appendix B */
voidÂ Â Â Â err_dump(const char *, ...) __attribute__((noreturn));
voidÂ Â Â Â err_quit(const char *, ...) __attribute__((noreturn));
voidÂ Â Â Â err_cont(int, const char *, ...);
voidÂ Â Â Â err_exit(int, const char *, ...) __attribute__((noreturn));
voidÂ Â Â Â err_ret(const char *, ...);
voidÂ Â Â Â err_sys(const char *, ...) __attribute__((noreturn));

voidÂ Â Â Â log_msg(const char *, ...);Â Â Â Â Â Â Â Â /* Appendix B */
voidÂ Â Â Â log_open(const char *, int, int);
voidÂ Â Â Â log_quit(const char *, ...) __attribute__((noreturn));
voidÂ Â Â Â log_ret(const char *, ...);
voidÂ Â Â Â log_sys(const char *, ...) __attribute__((noreturn));
voidÂ Â Â Â log_exit(int, const char *, ...) __attribute__((noreturn));

voidÂ Â Â Â TELL_WAIT(void);Â Â Â Â Â Â Â Â /* parent/child from Section 8.9 */
voidÂ Â Â Â TELL_PARENT(pid_t);
voidÂ Â Â Â TELL_CHILD(pid_t);
voidÂ Â Â Â WAIT_PARENT(void);
voidÂ Â Â Â WAIT_CHILD(void);

#endifÂ Â /* _APUE_H */

--------------

*Figure B.1* Our header: =apue.h=

Most programs need to include the following headers: =<stdio.h>=, =<stdlib.h>= (for the =exit= function prototype), and =<unistd.h>= (for all the standard UNIX function prototypes). So our header automatically includes these system headers, along with =<string.h>=. This also reduces the size of all the program listings in the text.

The reasons we include our header before all the normal system headers are to allow us to define anything that might be required by headers before they are included, to control the order in which header files are included, and to allow us to redefine anything that needs to be fixed up to hide the differences between systems.

*** B.2. Standard Error Routines


Two sets of error functions are used in most of the examples throughout the text to handle error conditions. One set begins with =err_= and outputs an error message to standard error. The other set begins with =log_= and is intended for daemon processes ([[file:part0025.xhtml#ch13][Chapter 13]]) that probably have no controlling terminal.

The reason for defining our own error functions is to let us write our error handling with a single line of C code, as in



if (error condition)
Â Â Â Â Â Â Â Â err_dump(printf format with any number of arguments);

instead of



if (error condition) {
Â Â Â Â Â Â Â Â charÂ Â buf[200];

Â Â Â Â Â Â Â Â sprintf(buf, printf format with any number of arguments);
Â Â Â Â Â Â Â Â perror(buf);
Â Â Â Â Â Â Â Â abort();
}

Our error functions use the variable-length argument list facility from ISO C. See Section 7.3 of Kernighan and Ritchie [[[file:part0038.xhtml#bib01_33][1988]]] for additional details. Be aware that this ISO C facility differs from the =varargs= facility provided by earlier systems (such as SVR3 and 4.3BSD). The names of the macros are the same, but the arguments to some of the macros have changed.

[[file:part0036.xhtml#app02fig02][Figure B.2]] summarizes the differences between the various error functions.

[[../Images/image01513.jpeg]]
*Figure B.2* Our standard error functions

[[file:part0036.xhtml#app02fig03][Figure B.3]] shows the error functions that output to standard error.



--------------

#include "apue.h"
#include <errno.h>Â Â Â Â Â Â /* for definition of errno */
#include <stdarg.h>Â Â Â Â Â /* ISO C variable aruments */

static void err_doit(int, int, const char *, va_list);

/*
Â * Nonfatal error related to a system call.
Â * Print a message and return.
Â */
void
err_ret(const char *fmt, ...)
{
Â Â Â Â va_listÂ Â Â Â Â ap;

Â Â Â Â va_start(ap, fmt);
Â Â Â Â err_doit(1, errno, fmt, ap);
Â Â Â Â va_end(ap);
}

/*
Â * Fatal error related to a system call.
Â * Print a message and terminate.
Â */
void
err_sys(const char *fmt, ...)
{
Â Â Â Â va_listÂ Â Â Â Â ap;

Â Â Â Â va_start(ap, fmt);
Â Â Â Â err_doit(1, errno, fmt, ap);
Â Â Â Â va_end(ap);
Â Â Â Â exit(1);
}

/*
Â * Nonfatal error unrelated to a system call.
Â * Error code passed as explict parameter.
Â * Print a message and return.
Â */
void
err_cont(int error, const char *fmt, ...)
{
Â Â Â Â va_listÂ Â Â Â Â ap;

Â Â Â Â va_start(ap, fmt);
Â Â Â Â err_doit(1, error, fmt, ap);
Â Â Â Â va_end(ap);
}

/*
Â * Fatal error unrelated to a system call.
Â * Error code passed as explict parameter.
Â * Print a message and terminate.
Â */
void
err_exit(int error, const char *fmt, ...)
{
Â Â Â Â va_listÂ Â Â Â Â ap;

Â Â Â Â va_start(ap, fmt);
Â Â Â Â err_doit(1, error, fmt, ap);
Â Â Â Â va_end(ap);
Â Â Â Â exit(1);
}

/*
Â * Fatal error related to a system call.
Â * Print a message, dump core, and terminate.
Â */
void
err_dump(const char *fmt, ...)
{
Â Â Â Â va_listÂ Â Â Â Â ap;

Â Â Â Â va_start(ap, fmt);
Â Â Â Â err_doit(1, errno, fmt, ap);
Â Â Â Â va_end(ap);
Â Â Â Â abort();Â Â Â Â Â Â Â Â /* dump core and terminate */
Â Â Â Â exit(1);Â Â Â Â Â Â Â Â /* shouldnâ€²t get here */
}

/*
Â * Nonfatal error unrelated to a system call.
Â * Print a message and return.
Â */
void
err_msg(const char *fmt, ...)
{
Â Â Â Â va_listÂ Â Â Â Â ap;

Â Â Â Â va_start(ap, fmt);
Â Â Â Â err_doit(0, 0, fmt, ap);
Â Â Â Â va_end(ap);
}

/*
Â * Fatal error unrelated to a system call.
Â * Print a message and terminate.
Â */
void
err_quit(const char *fmt, ...)
{
Â Â Â Â va_listÂ Â Â Â Â ap;

Â Â Â Â va_start(ap, fmt);
Â Â Â Â err_doit(0, 0, fmt, ap);
Â Â Â Â va_end(ap);
Â Â Â Â exit(1);
}
/*
Â * Print a message and return to caller.
Â * Caller specifies "errnoflag".
Â */
static void
err_doit(int errnoflag, int error, const char *fmt, va_list ap)
{
Â Â Â Â charÂ Â Â Â buf[MAXLINE];

Â Â Â Â vsnprintf(buf, MAXLINE-1, fmt, ap);
Â Â Â Â if (errnoflag)
Â Â Â Â Â Â Â Â snprintf(buf+strlen(buf), MAXLINE-strlen(buf)-1, ": %s",
Â Â Â Â Â Â Â Â Â Â strerror(error));
Â Â Â Â strcat(buf, "n");
Â Â Â Â fflush(stdout);Â Â Â Â Â /* in case stdout and stderr are the same */
Â Â Â Â fputs(buf, stderr);
Â Â Â Â fflush(NULL);Â Â Â Â Â Â Â /* flushes all stdio output streams */
}

--------------

*Figure B.3* Error functions that output to standard error

[[file:part0036.xhtml#app02fig04][Figure B.4]] shows the =log_XXX= error functions. These require the caller to define the variable =log_to_stderr= and set it nonzero if the process is not running as a daemon. In this case, the error messages are sent to standard error. If the =log_to_stderr= flag is 0, the =syslog= facility ([[file:part0025.xhtml#ch13lev1sec4][Section 13.4]]) is used.



--------------

/*
Â * Error routines for programs that can run as a daemon.
Â */

#include "apue.h"
#include <errno.h>Â Â Â Â Â Â /* for definition of errno */
#include <stdarg.h>Â Â Â Â Â /* ISO C variable arguments */
#include <syslog.h>

static void log_doit(int, int, int, const char *, va_list ap);

/*
Â * Caller must define and set this: nonzero if
Â * interactive, zero if daemon
Â */
extern intÂ Â log_to_stderr;

/*
Â * Initialize syslog(), if running as daemon.
Â */
void
log_open(const char *ident, int option, int facility)
{
Â Â Â Â if (log_to_stderr == 0)
Â Â Â Â Â Â Â Â openlog(ident, option, facility);
}

/*
Â * Nonfatal error related to a system call.
Â * Print a message with the systemâ€²s errno value and return.
Â */
void
log_ret(const char *fmt, ...)
{
Â Â Â Â va_listÂ Â Â Â Â ap;

Â Â Â Â va_start(ap, fmt);
Â Â Â Â log_doit(1, errno, LOG_ERR, fmt, ap);
Â Â Â Â va_end(ap);
}

/*
Â * Fatal error related to a system call.
Â * Print a message and terminate.
Â */
void
log_sys(const char *fmt, ...)
{
Â Â Â Â va_listÂ Â Â Â Â ap;

Â Â Â Â va_start(ap, fmt);
Â Â Â Â log_doit(1, errno, LOG_ERR, fmt, ap);
Â Â Â Â va_end(ap);
Â Â Â Â exit(2);
}
/*
Â * Nonfatal error unrelated to a system call.
Â * Print a message and return.
Â */
void
log_msg(const char *fmt, ...)
{
Â Â Â Â va_listÂ Â Â Â Â ap;

Â Â Â Â va_start(ap, fmt);
Â Â Â Â log_doit(0, 0, LOG_ERR, fmt, ap);
Â Â Â Â va_end(ap);
}

/*
Â * Fatal error unrelated to a system call.
Â * Print a message and terminate.
Â */
void
log_quit(const char *fmt, ...)
{
Â Â Â Â va_listÂ Â Â Â Â ap;

Â Â Â Â va_start(ap, fmt);
Â Â Â Â log_doit(0, 0, LOG_ERR, fmt, ap);
Â Â Â Â va_end(ap);
Â Â Â Â exit(2);
}

/*
Â * Fatal error related to a system call.
Â * Error number passed as an explicit parameter.
Â * Print a message and terminate.
Â */
void
log_exit(int error, const char *fmt, ...)
{
Â Â Â Â va_listÂ Â Â Â Â ap;

Â Â Â Â va_start(ap, fmt);
Â Â Â Â log_doit(1, error, LOG_ERR, fmt, ap);
Â Â Â Â va_end(ap);
Â Â Â Â exit(2);
}

/*
Â * Print a message and return to caller.
Â * Caller specifies "errnoflag" and "priority".
Â */
static void
log_doit(int errnoflag, int error, int priority, const char *fmt,
Â Â Â Â Â Â Â Â Â va_list ap)
{
Â Â Â Â charÂ Â Â Â buf[MAXLINE];

Â Â Â Â vsnprintf(buf, MAXLINE-1, fmt, ap);
Â Â Â Â if (errnoflag)
Â Â Â Â Â Â Â Â snprintf(buf+strlen(buf), MAXLINE-strlen(buf)-1, ": %s",
Â Â Â Â Â Â Â Â Â Â strerror(error));
Â Â Â Â strcat(buf, "n");
Â Â Â Â if (log_to_stderr) {
Â Â Â Â Â Â Â Â fflush(stdout);
Â Â Â Â Â Â Â Â fputs(buf, stderr);
Â Â Â Â Â Â Â Â fflush(stderr);
Â Â Â Â } else {
Â Â Â Â Â Â Â Â syslog(priority, "%s", buf);
Â Â Â Â }
}

--------------

*Figure B.4* Error functions for daemons


 call.
Â * Print a message and return.
Â */
void
log_msg(const char *fmt, ...)
{
Â Â Â Â va_listÂ Â Â Â Â ap;

Â Â Â Â va_start(ap, fmt);
Â Â Â Â log_doit(0, 0, LOG_ERR, fmt, ap);
Â Â Â Â va_end(ap);
}

/*
Â * Fatal error unrelated to a system call.
Â * Print a message and terminate.
Â */
void
log_quit(const char *fmt, ...)
{
Â Â Â Â va_listÂ Â Â Â Â ap;

Â Â Â Â va_start(ap, fmt);
Â Â Â Â log_doit(0, 0, LOG_ERR, fmt, ap);
Â Â Â Â va_end(ap);
Â Â Â Â exit(2);
}

/*
Â * Fatal error related to a system call.
Â * Error number passed as an explicit parameter.
Â * Print a message and terminate.
Â */
void
log_exit(int error, const char *fmt, ...)
{
Â Â Â Â va_listÂ Â Â Â Â ap;

Â Â Â Â va_start(ap, fmt);
Â Â Â Â log_doit(1, error, LOG_ERR, fmt, ap);
Â Â Â Â va_end(ap);
Â Â Â Â exit(2);
}

/*
Â * Print a message and return to caller.
Â * Caller specifies "errnoflag" and "priority".
Â */
static void
log_doit(int errnoflag, int error, int priority, const char *fmt,
Â Â Â Â Â Â Â Â Â va_list ap)
{
Â Â Â Â charÂ Â Â Â buf[MAXLINE];

Â Â Â Â vsnprintf(buf, MAXLINE-1, fmt, ap);
Â Â Â Â if (errnoflag)
Â Â Â Â Â Â Â Â snprintf(buf+strlen(buf), MAXLINE-strlen(buf)-1, ": %s",
Â Â Â Â Â Â Â Â Â Â strerror(error));
Â Â Â Â strcat(buf, "n");
Â Â Â Â if (log_to_stderr) {
Â Â Â Â Â Â Â Â fflush(stdout);
Â Â Â Â Â Â Â Â fputs(buf, stderr);
Â Â Â Â Â Â Â Â fflush(stderr);
Â Â Â Â } else {
Â Â Â Â Â Â Â Â syslog(priority, "%s", buf);
Â Â Â Â }
}

--------------

*Figure B.4* Error functions for daemons


 Â Â Â Â fflush(stderr);\\
Â Â Â Â } else {\\
Â Â Â Â Â Â Â Â syslog(priority, "%s", buf);\\
Â Â Â Â }\\
}

--------------

*Figure B.4* Error functions for daemons


