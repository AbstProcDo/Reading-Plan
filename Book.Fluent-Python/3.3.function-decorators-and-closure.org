* Chapter 7. Function Decorators and Closures

#+BEGIN_QUOTE
  There's been a number of complaints about the choice of the name “decorator” for this feature. The major one is that the name is not consistent with its use in the GoF book.^{[[[#ftn.id570923][39]]]} The name /decorator/ probably owes more to its use in the compiler area---a syntax tree is walked and annotated.

  --- PEP 318 --- Decorators for Functions and Methods

#+END_QUOTE

Function decorators let us “mark” functions in the source code to enhance their behavior in some way. This is powerful stuff, but mastering it requires understanding closures.

One of the newest reserved keywords in Python is =nonlocal=, introduced in Python 3.0. You can have a profitable life as a Python programmer without ever using it if you adhere to a strict regimen of class-centered object orientation. However, if you want to implement your own function decorators, you must know closures inside out, and then the need for =nonlocal= becomes obvious.

Aside from their application in decorators, closures are also essential for effective asynchronous programming with callbacks, and for coding in a functional style whenever it makes sense.

The end goal of this chapter is to explain exactly how function decorators work, from the simplest registration decorators to the rather more complicated parameterized ones. However, before we reach that goal we need to cover:

- How Python evaluates decorator syntax
- How Python decides whether a variable is local
- Why closures exist and how they work
- What problem is solved by =nonlocal=

With this grounding, we can tackle further decorator topics:

- Implementing a well-behaved decorator
- Interesting decorators in the standard library
- Implementing a parameterized decorator

We start with a very basic introduction to decorators, and then proceed with the rest of the items listed here.

** Decorators 101


A decorator is a callable that takes another function as argument (the decorated function).^{[[[#ftn.id717907][40]]]} The decorator may perform some processing with the decorated function, and returns it or replaces it with another function or callable object.

In other words, assuming an existing decorator named =decorate=, this code:

#+BEGIN_EXAMPLE
    @decorate
    def target():
        print('running target()')
#+END_EXAMPLE

Has the same effect as writing this:

#+BEGIN_EXAMPLE
    def target():
        print('running target()')

    target = decorate(target)
#+END_EXAMPLE

The end result is the same: at the end of either of these snippets, the =target= name does not necessarily refer to the original =target= function, but to whatever function is returned by =decorate(target)=.

To confirm that the decorated function is replaced, see the console session in [[file:ch07.html#decorator_replaces][Example 7-1]].



Example 7-1. A decorator usually replaces a function with a different one

#+BEGIN_EXAMPLE
    >>> def deco(func):
    ...     def inner():
    ...         print('running inner()')
    ...     return inner  
    ...
    >>> @deco
    ... def target():  
    ...     print('running target()')
    ...
    >>> target()  
    running inner()
    >>> target  
    <function deco.<locals>.inner at 0x10063b598>
#+END_EXAMPLE

- [[#CO68-1][[[file:callouts/1.png]]]]  :: =deco= returns its =inner= function object.

- [[#CO68-2][[[file:callouts/2.png]]]]  :: =target= is decorated by =deco=.

- [[#CO68-3][[[file:callouts/3.png]]]]  :: Invoking the decorated =target= actually runs =inner=.

- [[#CO68-4][[[file:callouts/4.png]]]]  :: Inspection reveals that =target= is a now a reference to =inner=.

Strictly speaking, decorators are just syntactic sugar. As we just saw, you can always simply call a decorator like any regular callable, passing another function. Sometimes that is actually convenient, especially when doing /metaprogramming/---changing program behavior at runtime.

To summarize: the first crucial fact about decorators is that they have the power to replace the decorated function with a different one. The second crucial fact is that they are executed immediately when a module is loaded. This is explained next.

** When Python Executes Decorators


A key feature of decorators is that they run right after the decorated function is defined. That is usually at /import time/ (i.e., when a module is loaded by Python). Consider /registration.py/ in [[file:ch07.html#registration_ex][Example 7-2]].



Example 7-2. The registration.py module

#+BEGIN_EXAMPLE
    registry = []   

    def register(func):   
        print('running register(%s)' % func)   
        registry.append(func)   
        return func   

    @register   
    def f1():
        print('running f1()')

    @register
    def f2():
        print('running f2()')

    def f3():   
        print('running f3()')

    def main():   
        print('running main()')
        print('registry ->', registry)
        f1()
        f2()
        f3()

    if __name__=='__main__':
        main()   
#+END_EXAMPLE

- [[#CO69-1][[[file:callouts/1.png]]]]  :: =registry= will hold references to functions decorated by =@register=.

- [[#CO69-2][[[file:callouts/2.png]]]]  :: =register= takes a function as argument.

- [[#CO69-3][[[file:callouts/3.png]]]]  :: Display what function is being decorated, for demonstration.

- [[#CO69-4][[[file:callouts/4.png]]]]  :: Include =func= in =registry=.

- [[#CO69-5][[[file:callouts/5.png]]]]  :: Return =func=: we must return a function; here we return the same received as argument.

- [[#CO69-6][[[file:callouts/6.png]]]]  :: =f1= and =f2= are decorated by =@register=.

- [[#CO69-7][[[file:callouts/7.png]]]]  :: =f3= is not decorated.

- [[#CO69-8][[[file:callouts/8.png]]]]  :: =main= displays the =registry=, then calls =f1()=, =f2()=, and =f3()=.

- [[#CO69-9][[[file:callouts/9.png]]]]  :: =main()= is only invoked if /registration.py/ runs as a script.

The output of running /registration.py/ as a script looks like this:

#+BEGIN_EXAMPLE
    $ python3 registration.py
    running register(<function f1 at 0x100631bf8>)
    running register(<function f2 at 0x100631c80>)
    running main()
    registry -> [<function f1 at 0x100631bf8>, <function f2 at 0x100631c80>]
    running f1()
    running f2()
    running f3()
#+END_EXAMPLE

Note that =register= runs (twice) before any other function in the module. When =register= is called, it receives as an argument the function object being decorated---for example, =<function f1 at 0x100631bf8>=.

After the module is loaded, the =registry= holds references to the two decorated functions: =f1= and =f2=. These functions, as well as =f3=, are only executed when explicitly called by =main=.

If /registration.py/ is imported (and not run as a script), the output is this:

#+BEGIN_EXAMPLE
    >>> import registration
    running register(<function f1 at 0x10063b1e0>)
    running register(<function f2 at 0x10063b268>)
#+END_EXAMPLE

At this time, if you look at the =registry=, here is what you get:

#+BEGIN_EXAMPLE
    >>> registration.registry
    [<function f1 at 0x10063b1e0>, <function f2 at 0x10063b268>]
#+END_EXAMPLE

The main point of [[file:ch07.html#registration_ex][Example 7-2]] is to emphasize that function decorators are executed as soon as the module is imported, but the decorated functions only run when they are explicitly invoked. This highlights the difference between what Pythonistas call /import time/ and /runtime/.

Considering how decorators are commonly employed in real code, [[file:ch07.html#registration_ex][Example 7-2]] is unusual in two ways:

- The decorator function is defined in the same module as the decorated functions. A real decorator is usually defined in one module and applied to functions in other modules.
- The =register= decorator returns the same function passed as argument. In practice, most decorators define an inner function and return it.

Even though the =register= decorator in [[file:ch07.html#registration_ex][Example 7-2]] returns the decorated function unchanged, that technique is not useless. Similar decorators are used in many Python web frameworks to add functions to some central registry---for example, a registry mapping URL patterns to functions that generate HTTP responses. Such registration decorators may or may not change the decorated function. The next section shows a practical example.

** Decorator-Enhanced Strategy Pattern


A registration decorator is a good enhancement to the ecommerce promotional discount from [[file:ch06.html#strategy_case_study][Case Study: Refactoring Strategy]].

Recall that our main issue with [[file:ch06.html#ex_strategy_best][Example 6-6]] is the repetition of the function names in their definitions and then in the =promos= list used by the =best_promo= function to determine the highest discount applicable. The repetition is problematic because someone may add a new promotional strategy function and forget to manually add it to the =promos= list---in which case, =best_promo= will silently ignore the new strategy, introducing a subtle bug in the system. [[file:ch07.html#ex_strategy_best31][Example 7-3]] solves this problem with a registration decorator.



Example 7-3. The promos list is filled by the promotion decorator

#+BEGIN_EXAMPLE
    promos = []   

    def promotion(promo_func):   
        promos.append(promo_func)
        return promo_func

    @promotion   
    def fidelity(order):
        """5% discount for customers with 1000 or more fidelity points"""
        return order.total() * .05 if order.customer.fidelity >= 1000 else 0

    @promotion
    def bulk_item(order):
        """10% discount for each LineItem with 20 or more units"""
        discount = 0
        for item in order.cart:
            if item.quantity >= 20:
                discount += item.total() * .1
        return discount

    @promotion
    def large_order(order):
        """7% discount for orders with 10 or more distinct items"""
        distinct_items = {item.product for item in order.cart}
        if len(distinct_items) >= 10:
            return order.total() * .07
        return 0

    def best_promo(order):   
        """Select best discount available
        """
        return max(promo(order) for promo in promos)
#+END_EXAMPLE

- [[#CO70-1][[[file:callouts/1.png]]]]  :: The =promos= list starts empty.

- [[#CO70-2][[[file:callouts/2.png]]]]  :: =promotion= decorator returns =promo_func= unchanged, after adding it to the =promos= list.

- [[#CO70-3][[[file:callouts/3.png]]]]  :: Any function decorated by =@promotion= will be added to =promos=.

- [[#CO70-4][[[file:callouts/4.png]]]]  :: No changes needed to =best_promos=, because it relies on the =promos= list.

This solution has several advantages over the others presented in [[file:ch06.html#strategy_case_study][Case Study: Refactoring Strategy]]:

- The promotion strategy functions don't have to use special names (i.e., they don't need to use the =_promo= suffix).
- The =@promotion= decorator highlights the purpose of the decorated function, and also makes it easy to temporarily disable a promotion: just comment out the decorator.
- Promotional discount strategies may be defined in other modules, anywhere in the system, as long as the =@promotion= decorator is applied to them.

Most decorators do change the decorated function. They usually do it by defining an inner function and returning it to replace the decorated function. Code that uses inner functions almost always depends on closures to operate correctly. To understand closures, we need to take a step back a have a close look at how variable scopes work in Python.

** Variable Scope Rules


In [[file:ch07.html#ex_global_undef][Example 7-4]], we define and test a function that reads two variables: a local variable =a=, defined as function parameter, and variable =b= that is not defined anywhere in the function.



Example 7-4. Function reading a local and a global variable

#+BEGIN_EXAMPLE
    >>> def f1(a):
    ...     print(a)
    ...     print(b)
    ...
    >>> f1(3)
    3
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "<stdin>", line 3, in f1
    NameError: global name 'b' is not defined
#+END_EXAMPLE

The error we got is not surprising. Continuing from [[file:ch07.html#ex_global_undef][Example 7-4]], if we assign a value to a global =b= and then call =f1=, it works:

#+BEGIN_EXAMPLE
    >>> b = 6
    >>> f1(3)
    3
    6
#+END_EXAMPLE

Now, let's see an example that may surprise you.

Take a look at the =f2= function in [[file:ch07.html#ex_local_unbound][Example 7-5]]. Its first two lines are the same as =f1= in [[file:ch07.html#ex_global_undef][Example 7-4]], then it makes an assignment to =b=, and prints its value. But it fails at the second =print=, before the assignment is made.



Example 7-5. Variable b is local, because it is assigned a value in the body of the function

#+BEGIN_EXAMPLE
    >>> b = 6
    >>> def f2(a):
    ...     print(a)
    ...     print(b)
    ...     b = 9
    ...
    >>> f2(3)
    3
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "<stdin>", line 3, in f2
    UnboundLocalError: local variable 'b' referenced before assignment
#+END_EXAMPLE

Note that the output starts with =3=, which proves that the =print(a)= statement was executed. But the second one, =print(b)=, never runs. When I first saw this I was surprised, thinking that =6= should be printed, because there is a global variable =b= and the assignment to the local =b= is made after =print(b)=.

But the fact is, when Python compiles the body of the function, it decides that =b= is a local variable because it is assigned within the function. The generated bytecode reflects this decision and will try to fetch =b= from the local environment. Later, when the call =f2(3)= is made, the body of =f2= fetches and prints the value of the local variable =a=, but when trying to fetch the value of local variable =b= it discovers that =b= is unbound.

This is not a bug, but a design choice: Python does not require you to declare variables, but assumes that a variable assigned in the body of a function is local. This is much better than the behavior of JavaScript, which does not require variable declarations either, but if you do forget to declare that a variable is local (with =var=), you may clobber a global variable without knowing.

If we want the interpreter to treat =b= as a global variable in spite of the assignment within the function, we use the =global= declaration:

#+BEGIN_EXAMPLE
    >>> def f3(a):
    ...     global b
    ...     print(a)
    ...     print(b)
    ...     b = 9
    ...
    >>> f3(3)
    3
    6
    >>> b
    9

    >>> f3(3)
    a = 3
    b = 8
    b = 30
    >>> b
    30
    >>>
#+END_EXAMPLE

After this closer look at how variable scopes work in Python, we can tackle closures in the next section, [[file:ch07.html#closures_sec][Closures]]. If you are curious about the bytecode differences between the functions in Examples [[file:ch07.html#ex_global_undef][7-4]] and [[file:ch07.html#ex_local_unbound][7-5]], see the following sidebar.

Comparing Bytecodes

The =dis= module provides an easy way to disassemble the bytecode of Python functions. Read Examples [[file:ch07.html#ex_f1_dis][7-6]] and [[file:ch07.html#ex_f2_dis][7-7]] to see the bytecodes for =f1= and =f2= from Examples [[file:ch07.html#ex_global_undef][7-4]] and [[file:ch07.html#ex_local_unbound][7-5]].



Example 7-6. Disassembly of the f1 function from [[file:ch07.html#ex_global_undef][Example 7-4]]

#+BEGIN_EXAMPLE
    >>> from dis import dis
    >>> dis(f1)
      2           0 LOAD_GLOBAL              0 (print)  
                  3 LOAD_FAST                0 (a)  
                  6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
                  9 POP_TOP

      3          10 LOAD_GLOBAL              0 (print)
                 13 LOAD_GLOBAL              1 (b)  
                 16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
                 19 POP_TOP
                 20 LOAD_CONST               0 (None)
                 23 RETURN_VALUE
#+END_EXAMPLE

- [[#CO71-1][[[file:callouts/1.png]]]]  :: Load global name =print=.

- [[#CO71-2][[[file:callouts/2.png]]]]  :: Load local name =a=.

- [[#CO71-3][[[file:callouts/3.png]]]]  :: Load global name =b=.

Contrast the bytecode for =f1= shown in [[file:ch07.html#ex_f1_dis][Example 7-6]] with the bytecode for =f2= in [[file:ch07.html#ex_f2_dis][Example 7-7]].



Example 7-7. Disassembly of the f2 function from [[file:ch07.html#ex_local_unbound][Example 7-5]]

#+BEGIN_EXAMPLE
    >>> dis(f2)
      2           0 LOAD_GLOBAL              0 (print)
                  3 LOAD_FAST                0 (a)
                  6 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
                  9 POP_TOP

      3          10 LOAD_GLOBAL              0 (print)
                 13 LOAD_FAST                1 (b)  
                 16 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
                 19 POP_TOP

      4          20 LOAD_CONST               1 (9)
                 23 STORE_FAST               1 (b)
                 26 LOAD_CONST               0 (None)
                 29 RETURN_VALUE
#+END_EXAMPLE

- [[#CO72-1][[[file:callouts/1.png]]]]  :: Load /local/ name =b=. This shows that the compiler considers =b= a local variable, even if the assignment to =b= occurs later, because the nature of the variable---whether it is local or not---cannot change the body of the function.

The CPython VM that runs the bytecode is a stack machine, so the operations =LOAD= and =POP= refer to the stack. It is beyond the scope of this book to further describe the Python opcodes, but they are documented along with the =dis= module in [[http://docs.python.org/3/library/dis.html][dis --- Disassembler for Python bytecode]].

** Closures


In the blogosphere, closures are sometimes confused with anonymous functions. The reason why many confuse them is historic: defining functions inside functions is not so common, until you start using anonymous functions. And closures only matter when you have nested functions. So a lot of people learn both concepts at the same time.

Actually, a closure is a function with an extended scope that encompasses nonglobal variables referenced in the body of the function but not defined there. It does not matter whether the function is anonymous or not; what matters is that it can access nonglobal variables that are defined outside of its body.

This is a challenging concept to grasp, and is better approached through an example.

Consider an =avg= function to compute the mean of an ever-increasing series of values; for example, the average closing price of a commodity over its entire history. Every day a new price is added, and the average is computed taking into account all prices so far.

Starting with a clean slate, this is how =avg= could be used:

#+BEGIN_EXAMPLE
    >>> avg(10)
    10.0
    >>> avg(11)
    10.5
    >>> avg(12)
    11.0
#+END_EXAMPLE

Where does =avg= come from, and where does it keep the history of previous values?

For starters, [[file:ch07.html#ex_average_oo][Example 7-8]] is a class-based implementation.



Example 7-8. average_oo.py: A class to calculate a running average

#+BEGIN_EXAMPLE
    class Averager():

        def __init__(self):
            self.series = []

        def __call__(self, new_value):
            self.series.append(new_value)
            total = sum(self.series)
            return total/len(self.series)
#+END_EXAMPLE

The =Averager= class creates instances that are callable:

#+BEGIN_EXAMPLE
    >>> avg = Averager()
    >>> avg(10)
    10.0
    >>> avg(11)
    10.5
    >>> avg(12)
    11.0
#+END_EXAMPLE

Now, [[file:ch07.html#ex_average_fn][Example 7-9]] is a functional implementation, using the higher-order function =make_averager=.



Example 7-9. average.py: A higher-order function to calculate a running average

#+BEGIN_EXAMPLE
    def make_averager():
        series = []

        def averager(new_value):
            series.append(new_value)
            total = sum(series)
            return total/len(series)

        return averager
#+END_EXAMPLE

When invoked, =make_averager= returns an =averager= function object. Each time an =averager= is called, it appends the passed argument to the series, and computes the current average, as shown in [[file:ch07.html#ex_average_demo1][Example 7-10]].



Example 7-10. Testing [[file:ch07.html#ex_average_fn][Example 7-9]]

#+BEGIN_EXAMPLE
    >>> avg = make_averager()
    >>> avg(10)
    10.0
    >>> avg(11)
    10.5
    >>> avg(12)
    11.0
#+END_EXAMPLE

Note the similarities of the examples: we call =Averager()= or =make_averager()= to get a callable object =avg= that will update the historical series and calculate the current mean. In [[file:ch07.html#ex_average_oo][Example 7-8]], =avg= is an instance of =Averager=, and in [[file:ch07.html#ex_average_fn][Example 7-9]] it is the inner function, =averager=. Either way, we just call =avg(n)= to include =n= in the series and get the updated mean.

It's obvious where the =avg= of the =Averager= class keeps the history: the =self.series= instance attribute. But where does the =avg= function in the second example find the =series=?

Note that =series= is a local variable of =make_averager= because the initialization =series = []= happens in the body of that function. But when =avg(10)= is called, =make_averager= has already returned, and its local scope is long gone.

Within =averager=, =series= is a /free variable/. This is a technical term meaning a variable that is not bound in the local scope. See [[file:ch07.html#closure_fig][Figure 7-1]].



[[file:images/flup_0701.png]]

Figure 7-1. The closure for averager extends the scope of that function to include the binding for the free variable series.

Inspecting the returned =averager= object shows how Python keeps the names of local and free variables in the =__code__= attribute that represents the compiled body of the function. [[file:ch07.html#ex_average_demo2][Example 7-11]] demonstrates.



Example 7-11. Inspecting the function created by make_averager in [[file:ch07.html#ex_average_fn][Example 7-9]]

#+BEGIN_EXAMPLE
    >>> avg.__code__.co_varnames
    ('new_value', 'total')
    >>> avg.__code__.co_freevars
    ('series',)
#+END_EXAMPLE

The binding for =series= is kept in the =__closure__= attribute of the returned function =avg=. Each item in =avg.__closure__= corresponds to a name in =avg.__code__.co_freevars=. These items are =cells=, and they have an attribute called =cell_contents= where the actual value can be found. [[file:ch07.html#ex_average_demo3][Example 7-12]] shows these attributes.



Example 7-12. Continuing from [[file:ch07.html#ex_average_demo1][Example 7-10]]

#+BEGIN_EXAMPLE
    >>> avg.__code__.co_freevars
    ('series',)
    >>> avg.__closure__
    (<cell at 0x107a44f78: list object at 0x107a91a48>,)
    >>> avg.__closure__[0].cell_contents
    [10, 11, 12]
#+END_EXAMPLE

To summarize: a closure is a function that retains the bindings of the free variables that exist when the function is defined, so that they can be used later when the function is invoked and the defining scope is no longer available.

Note that the only situation in which a function may need to deal with external variables that are nonglobal is when it is nested in another function.

** The nonlocal Declaration


Our previous implementation of =make_averager= was not efficient. In [[file:ch07.html#ex_average_fn][Example 7-9]], we stored all the values in the historical series and computed their =sum= every time =averager= was called. A better implementation would just store the total and the number of items so far, and compute the mean from these two numbers.

[[file:ch07.html#ex_average_broken][Example 7-13]] is a broken implementation, just to make a point. Can you see where it breaks?



Example 7-13. A broken higher-order function to calculate a running average without keeping all history

#+BEGIN_EXAMPLE
    def make_averager():
        count = 0
        total = 0

        def averager(new_value):
            count += 1
            total += new_value
            return total / count

        return averager
#+END_EXAMPLE

If you try [[file:ch07.html#ex_average_broken][Example 7-13]], here is what you get:

#+BEGIN_EXAMPLE
    >>> avg = make_averager()
    >>> avg(10)
    Traceback (most recent call last):
      ...
    UnboundLocalError: local variable 'count' referenced before assignment
    >>>
#+END_EXAMPLE

The problem is that the statement =count += 1= actually means the same as =count = count + 1=, when =count= is a number or any immutable type. So we are actually assigning to =count= in the body of =averager=, and that makes it a local variable. The same problem affects the =total= variable.

We did not have this problem in [[file:ch07.html#ex_average_fn][Example 7-9]] because we never assigned to the =series= name; we only called =series.append= and invoked =sum= and =len= on it. So we took advantage of the fact that lists are mutable.

But with immutable types like numbers, strings, tuples, etc., all you can do is read, but never update. If you try to rebind them, as in =count = count + 1=, then you are implicitly creating a local variable =count=. It is no longer a free variable, and therefore it is not saved in the closure.

To work around this, the =nonlocal= declaration was introduced in Python 3. It lets you flag a variable as a free variable even when it is assigned a new value within the function. If a new value is assigned to a =nonlocal= variable, the binding stored in the closure is changed. A correct implementation of our newest =make_averager= looks like [[file:ch07.html#ex_average_fixed][Example 7-14]].



Example 7-14. Calculate a running average without keeping all history (fixed with the use of nonlocal)

#+BEGIN_EXAMPLE
    def make_averager():
        count = 0
        total = 0

        def averager(new_value):
            nonlocal count, total
            count += 1
            total += new_value
            return total / count

        return averager
#+END_EXAMPLE

*** Getting by without nonlocal in Python 2


Graham Dumpleton and Lennart Regebro---one of this book's technical reviewers---argue that decorators are best coded as classes implementing =__call__=, and not as functions like the examples in this chapter. I agree that approach is better for non-trivial decorators, but to explain the basic idea of this language feature, functions are easier to understand.

** Stacked Decorators


[[file:ch07.html#fibo_demo_lru_ex][Example 7-19]] demonstrated the use of stacked decorators: =@lru_cache= is applied on the result of =@clock= over =fibonacci=. In [[file:ch07.html#singledispatch_ex][Example 7-21]], the =@htmlize.register= decorator was applied twice to the last function in the module.

When two decorators =@d1= and =@d2= are applied to a function =f= in that order, the result is the same as =f = d1(d2(f))=.

In other words, this:

#+BEGIN_EXAMPLE
    @d1
    @d2
    def f():
        print('f')
#+END_EXAMPLE

Is the same as:

#+BEGIN_EXAMPLE
    def f():
        print('f')

    f = d1(d2(f))
#+END_EXAMPLE

Besides stacked decorators, this chapter has shown some decorators that take arguments, for example, =@lru_cache()= and the =htmlize.register(«type»)= produced by =@singledispatch= in [[file:ch07.html#singledispatch_ex][Example 7-21]]. The next section shows how to build decorators that accept parameters.

** Parameterized Decorators


When parsing a decorator in source code, Python takes the decorated function and passes it as the first argument to the decorator function. So how do you make a decorator accept other arguments? The answer is: make a decorator factory that takes those arguments and returns a decorator, which is then applied to the function to be decorated. Confusing? Sure. Let's start with an example based on the simplest decorator we've seen: =register= in [[file:ch07.html#registration_ex_repeat][Example 7-22]].



Example 7-22. Abridged registration.py module from [[file:ch07.html#registration_ex][Example 7-2]], repeated here for convenience

#+BEGIN_EXAMPLE
    registry = []

    def register(func):
        print('running register(%s)' % func)
        registry.append(func)
        return func

    @register
    def f1():
        print('running f1()')

    print('running main()')
    print('registry ->', registry)
    f1()
#+END_EXAMPLE

*** A Parameterized Registration Decorator
    :PROPERTIES:
    :CUSTOM_ID: _a_parameterized_registration_decorator
    :CLASS: title
    :END:

In order to make it easy to enable or disable the function registration performed by =register=, we'll make it accept an optional =active= parameter which, if =False=, skips registering the decorated function. [[file:ch07.html#registration_param_ex][Example 7-23]] shows how. Conceptually, the new =register= function is not a decorator but a decorator factory. When called, it returns the actual decorator that will be applied to the target function.



Example 7-23. To accept parameters, the new register decorator must be called as a function

#+BEGIN_EXAMPLE
    registry = set()   

    def register(active=True):   
        def decorate(func):   
            print('running register(active=%s)->decorate(%s)'
                  % (active, func))
            if active:    
                registry.add(func)
            else:
                registry.discard(func)   

            return func   
        return decorate   

    @register(active=False)   
    def f1():
        print('running f1()')

    @register()   
    def f2():
        print('running f2()')

    def f3():
        print('running f3()')
#+END_EXAMPLE

- [[#CO77-1][[[file:callouts/1.png]]]]  :: =registry= is now a =set=, so adding and removing functions is faster.

- [[#CO77-2][[[file:callouts/2.png]]]]  :: =register= takes an optional keyword argument.

- [[#CO77-3][[[file:callouts/3.png]]]]  :: The =decorate= inner function is the actual decorator; note how it takes a function as argument.

- [[#CO77-4][[[file:callouts/4.png]]]]  :: Register =func= only if the =active= argument (retrieved from the closure) is =True=.

- [[#CO77-5][[[file:callouts/5.png]]]]  :: If =not active= and =func in registry=, remove it.

- [[#CO77-6][[[file:callouts/6.png]]]]  :: Because =decorate= is a decorator, it must return a function.

- [[#CO77-7][[[file:callouts/7.png]]]]  :: =register= is our decorator factory, so it returns =decorate=.

- [[#CO77-8][[[file:callouts/8.png]]]]  :: The =@register= factory must be invoked as a function, with the desired parameters.

- [[#CO77-9][[[file:callouts/9.png]]]]  :: If no parameters are passed, =register= must still be called as a function---=@register()=---i.e., to return the actual decorator, =decorate=.

The main point is that =register()= returns =decorate=, which is then applied to the decorated function.

The code in [[file:ch07.html#registration_param_ex][Example 7-23]] is in a /registration_param.py/ module. If we import it, this is what we get:

#+BEGIN_EXAMPLE
    >>> import registration_param
    running register(active=False)->decorate(<function f1 at 0x10063c1e0>)
    running register(active=True)->decorate(<function f2 at 0x10063c268>)
    >>> registration_param.registry
    [<function f2 at 0x10063c268>]
#+END_EXAMPLE

Note how only the =f2= function appears in the =registry=; =f1= does not appear because =active=False= was passed to the =register= decorator factory, so the =decorate= that was applied to =f1= did not add it to the =registry=.

If, instead of using the =@= syntax, we used =register= as a regular function, the syntax needed to decorate a function =f= would be =register()(f)= to add =f= to the =registry=, or =register(active=False)(f)= to not add it (or remove it). See [[file:ch07.html#registration_param_demo][Example 7-24]] for a demo of adding and removing functions to the =registry=.



Example 7-24. Using the registration_param module listed in [[file:ch07.html#registration_param_ex][Example 7-23]]

#+BEGIN_EXAMPLE
    >>> from registration_param import *
    running register(active=False)->decorate(<function f1 at 0x10073c1e0>)
    running register(active=True)->decorate(<function f2 at 0x10073c268>)
    >>> registry  # 
    {<function f2 at 0x10073c268>}
    >>> register()(f3)  # 
    running register(active=True)->decorate(<function f3 at 0x10073c158>)
    <function f3 at 0x10073c158>
    >>> registry  # 
    {<function f3 at 0x10073c158>, <function f2 at 0x10073c268>}
    >>> register(active=False)(f2)  # 
    running register(active=False)->decorate(<function f2 at 0x10073c268>)
    <function f2 at 0x10073c268>
    >>> registry  # 
    {<function f3 at 0x10073c158>}
#+END_EXAMPLE

- [[#CO78-1][[[file:callouts/1.png]]]]  :: When the module is imported, =f2= is in the =registry=.

- [[#CO78-2][[[file:callouts/2.png]]]]  :: The =register()= expression returns =decorate=, which is then applied to =f3=.

- [[#CO78-3][[[file:callouts/3.png]]]]  :: The previous line added =f3= to the =registry=.

- [[#CO78-4][[[file:callouts/4.png]]]]  :: This call removes =f2= from the =registry=.

- [[#CO78-5][[[file:callouts/5.png]]]]  :: Confirm that only =f3= remains in the =registry=.

The workings of parameterized decorators are fairly involved, and the one we've just discussed is simpler than most. Parameterized decorators usually replace the decorated function, and their construction requires yet another level of nesting. Touring such function pyramids is our next adventure.

*** The Parameterized Clock Decorator
    :PROPERTIES:
    :CUSTOM_ID: _the_parameterized_clock_decorator
    :CLASS: title
    :END:

In this section, we'll revisit the =clock= decorator, adding a feature: users may pass a format string to control the output of the decorated function. See [[file:ch07.html#clockdeco_param_ex][Example 7-25]].

*** Note
    :PROPERTIES:
    :CUSTOM_ID: note-1
    :CLASS: title
    :END:

For simplicity, [[file:ch07.html#clockdeco_param_ex][Example 7-25]] is based on the initial =clock= implementation from [[file:ch07.html#ex_clockdeco][Example 7-15]], and not the improved one from [[file:ch07.html#ex_clockdeco2][Example 7-17]] that uses =@functools.wraps=, adding yet another function layer.



Example 7-25. Module clockdeco_param.py: the parameterized clock decorator

#+BEGIN_EXAMPLE
    import time

    DEFAULT_FMT = '[{elapsed:0.8f}s] {name}({args}) -> {result}'

    def clock(fmt=DEFAULT_FMT):   
        def decorate(func):       
            def clocked(*_args):  
                t0 = time.time()
                _result = func(*_args)   
                elapsed = time.time() - t0
                name = func.__name__
                args = ', '.join(repr(arg) for arg in _args)   
                result = repr(_result)   
                print(fmt.format(**locals()))   
                return _result   
            return clocked   
        return decorate   

    if __name__ == '__main__':

        @clock()   
        def snooze(seconds):
            time.sleep(seconds)

        for i in range(3):
            snooze(.123)
#+END_EXAMPLE

- [[#CO79-1][[[file:callouts/1.png]]]]  :: =clock= is our parameterized decorator factory.

- [[#CO79-2][[[file:callouts/2.png]]]]  :: =decorate= is the actual decorator.

- [[#CO79-3][[[file:callouts/3.png]]]]  :: =clocked= wraps the decorated function.

- [[#CO79-4][[[file:callouts/4.png]]]]  :: =_result= is the actual result of the decorated function.

- [[#CO79-5][[[file:callouts/5.png]]]]  :: =_args= holds the actual arguments of =clocked=, while =args= is =str= used for display.

- [[#CO79-6][[[file:callouts/6.png]]]]  :: =result= is the =str= representation of =_result=, for display.

- [[#CO79-7][[[file:callouts/7.png]]]]  :: Using =**locals()= here allows any local variable of =clocked= to be referenced in the =fmt=.

- [[#CO79-8][[[file:callouts/8.png]]]]  :: =clocked= will replace the decorated function, so it should return whatever that function returns.

- [[#CO79-9][[[file:callouts/9.png]]]]  :: =decorate= returns =clocked=.

- [[#CO79-10][[[file:callouts/10.png]]]]  :: =clock= returns =decorate=.

- [[#CO79-11][[[file:callouts/11.png]]]]  :: In this self test, =clock()= is called without arguments, so the decorator applied will use the default format =str=.

If you run [[file:ch07.html#clockdeco_param_ex][Example 7-25]] from the shell, this is what you get:

#+BEGIN_EXAMPLE
    $ python3 clockdeco_param.py
    [0.12412500s] snooze(0.123) -> None
    [0.12411904s] snooze(0.123) -> None
    [0.12410498s] snooze(0.123) -> None
#+END_EXAMPLE

To exercise the new functionality, Examples [[file:ch07.html#ex_clockdecoparam_demo1][7-26]] and [[file:ch07.html#ex_clockdecoparam_demo2][7-27]] are two other modules using =clockdeco_param=, and the outputs they generate.



Example 7-26. clockdeco_param_demo1.py

#+BEGIN_EXAMPLE
    import time
    from clockdeco_param import clock

    @clock('{name}: {elapsed}s')
    def snooze(seconds):
        time.sleep(seconds)

    for i in range(3):
        snooze(.123)
#+END_EXAMPLE

Output of [[file:ch07.html#ex_clockdecoparam_demo1][Example 7-26]]:

#+BEGIN_EXAMPLE
    $ python3 clockdeco_param_demo1.py
    snooze: 0.12414693832397461s
    snooze: 0.1241159439086914s
    snooze: 0.12412118911743164s
#+END_EXAMPLE



Example 7-27. clockdeco_param_demo2.py

#+BEGIN_EXAMPLE
    import time
    from clockdeco_param import clock

    @clock('{name}({args}) dt={elapsed:0.3f}s')
    def snooze(seconds):
        time.sleep(seconds)

    for i in range(3):
        snooze(.123)
#+END_EXAMPLE

Output of [[file:ch07.html#ex_clockdecoparam_demo2][Example 7-27]]:

#+BEGIN_EXAMPLE
    $ python3 clockdeco_param_demo2.py
    snooze(0.123) dt=0.124s
    snooze(0.123) dt=0.124s
    snooze(0.123) dt=0.124s
#+END_EXAMPLE

This ends our exploration of decorators as far as space permits within the scope of this book. See [[file:ch07.html#decorator_further][Further Reading]], in particular Graham Dumpleton's blog and =wrapt= module for industrial-strength techniques when building decorators.

*** Note
    :PROPERTIES:
    :CUSTOM_ID: note-2
    :CLASS: title
    :END:

Graham Dumpleton and Lennart Regebro---one of this book's technical reviewers---argue that decorators are best coded as classes implementing =__call__=, and not as functions like the examples in this chapter. I agree that approach is better for non-trivial decorators, but to explain the basic idea of this language feature, functions are easier to understand.

** Chapter Summary


We covered a lot of ground in this chapter, but I tried to make the journey as smooth as possible even if the terrain is rugged. After all, we did enter the realm of metaprogramming.

We started with a simple =@register= decorator without an inner function, and finished with a parameterized =@clock()= involving two levels of nested functions.

Registration decorators, though simple in essence, have real applications in advanced Python frameworks. We applied the registration idea to an improvement of our Strategy design pattern refactoring from [[file:ch06.html][Chapter 6]].

Parameterized decorators almost aways involve at least two nested functions, maybe more if you want to use =@functools.wraps= to produce a decorator that provides better support for more advanced techniques. One such technique is stacked decorators, which we briefly covered.

We also visited two awesome function decorators provided in the =functools= module of standard library: =@lru_cache()= and =@singledispatch=.

Understanding how decorators actually work required covering the difference between /import time/ and /runtime/, then diving into variable scoping, closures, and the new =nonlocal= declaration. Mastering closures and =nonlocal= is valuable not only to build decorators, but also to code event-oriented programs for GUIs or asynchronous I/O with callbacks.

** Further Reading


Chapter 9, “Metaprogramming,” of the /Python Cookbook, Third Edition/ by David Beazley and Brian K. Jones (O'Reilly), has several recipes from elementary decorators to very sophisticated ones, including one that can be called as a regular decorator or as a decorator factory, e.g., =@clock= or =@clock()=. That's “Recipe 9.6. Defining a Decorator That Takes an Optional Argument” in that cookbook.

Graham Dumpleton has a [[http://bit.ly/1DePPcl][series of in-depth blog posts]] about techniques for implementing well-behaved decorators, starting with [[http://bit.ly/1DePVRi][“How You Implemented Your Python Decorator is Wrong”]]. His deep expertise in this matter is also nicely packaged in the [[http://wrapt.readthedocs.org/en/latest/][wrapt]] module he wrote to simplify the implementation of decorators and dynamic function wrappers, which support introspection and behave correctly when further decorated, when applied to methods and when used as descriptors. (Descriptors are the subject of chapter [[file:ch20.html][Chapter 20]].)

Michele Simionato authored a package aiming to “simplify the usage of decorators for the average programmer, and to popularize decorators by showing various non-trivial examples,” according to the docs. It's available on PyPI as the [[https://pypi.python.org/pypi/decorator][decorator package]].

Created when decorators were still a new feature in Python, the [[https://wiki.python.org/moin/PythonDecoratorLibrary][Python Decorator Library wiki page]] has dozens of examples. Because that page started years ago, some of the techniques shown have been superseded, but the page is still an excellent source of inspiration.

[[http://www.python.org/dev/peps/pep-0443/][PEP 443]] provides the rationale and a detailed description of the single-dispatch generic functions' facility. An old (March 2005) blog post by Guido van Rossum, [[http://www.artima.com/weblogs/viewpost.jsp?thread=101605][“Five-Minute Multimethods in Python”]], walks through an implementation of generic functions (a.k.a. multimethods) using decorators. His code supports multiple-dispatch (i.e., dispatch based on more than one positional argument). Guido's multimethods code is interesting, but it's a didactic example. For a modern, production-ready implementation of multiple-dispatch generic functions, check out [[http://reg.readthedocs.org/en/latest/][Reg]] by Martijn Faassen---author of the model-driven and REST-savvy [[http://morepath.readthedocs.org/en/latest/][Morepath]] web framework.

[[http://effbot.org/zone/closure.htm][“Closures in Python”]] is a short blog post by Fredrik Lundh that explains the terminology of closures.

[[http://www.python.org/dev/peps/pep-3104/][PEP 3104 --- Access to Names in Outer Scopes]] describes the introduction of the =nonlocal= declaration to allow rebinding of names that are neither local nor global. It also includes an excellent overview of how this issue is resolved in other dynamic languages (Perl, Ruby, JavaScript, etc.) and the pros and cons of the design options available to Python.

On a more theoretical level, [[http://www.python.org/dev/peps/pep-0227/][PEP 227 --- Statically Nested Scopes]] documents the introduction of lexical scoping as an option in Python 2.1 and as a standard in Python 2.2, explaining the rationale and design choices for the implementation of closures in Python.



Soapbox

The designer of any language with first-class functions faces this issue: being first-class objects, functions are defined in a certain scope but may be invoked in other scopes. The question is: how to evaluate the free variables? The first and simplest answer is “dynamic scope.” This means that free variables are evaluated by looking into the environment where the function is invoked.

If Python had dynamic scope and no closures, we could improvise =avg=---similar to [[file:ch07.html#ex_average_fn][Example 7-9]]---like this:

#+BEGIN_EXAMPLE
    >>> ### this is not a real Python console session! ###
    >>> avg = make_averager()
    >>> series = []  # 
    >>> avg(10)
    10.0
    >>> avg(11)  # 
    10.5
    >>> avg(12)
    11.0
    >>> series = [1]  # 
    >>> avg(5)
    3.0
#+END_EXAMPLE

- [[#CO80-1][[[file:callouts/1.png]]]]  :: Before using =avg=, we have to define =series = []= ourselves, so we must know that =averager= (inside =make_averager=) refers to a =list= by that name.

- [[#CO80-2][[[file:callouts/2.png]]]]  :: Behind the scenes, =series= is used to accumulate the values to be averaged.

- [[#CO80-3][[[file:callouts/3.png]]]]  :: When =series = [1]= is executed, the previous list is lost. This could happen by accident, when handling two independent running averages at the same time.

Functions should be black boxes, with their implementation hidden from users. But with dynamic scope, if a function uses free variables, the programmer has to know its internals to set up an environment where it works correctly.

On the other hand, dynamic scope is easier to implement, which is probably why it was the path taken by John McCarthy when he created Lisp, the first language to have first-class functions. Paul Graham's article [[http://www.paulgraham.com/rootsoflisp.html][“The Roots of Lisp”]] is an accessible explanation of John McCarthy's original paper about the Lisp language: [[http://bit.ly/mccarthy_recursive][“Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I”]]. McCarthy's paper is a masterpiece as great as Beethoven's 9th Symphony. Paul Graham translated it for the rest of us, from mathematics to English and running code.

Paul Graham's commentary also shows how tricky dynamic scoping is. Quoting from “The Roots of Lisp”:

#+BEGIN_QUOTE
  It's an eloquent testimony to the dangers of dynamic scope that even the very first example of higher-order Lisp functions was broken because of it. It may be that McCarthy was not fully aware of the implications of dynamic scope in 1960. Dynamic scope remained in Lisp implementations for a surprisingly long time---until Sussman and Steele developed Scheme in 1975. Lexical scope does not complicate the definition of =eval= very much, but it may make compilers harder to write.
#+END_QUOTE

Today, lexical scope is the norm: free variables are evaluated considering the environment where the function is defined. Lexical scope complicates the implementation of languages with first-class functions, because it requires the support of closures. On the other hand, lexical scope makes source code easier to read. Most languages invented since Algol have lexical scope.

For many years, Python =lambdas= did not provide closures, contributing to the bad name of this feature among functional-programming geeks in the blogosphere. This was fixed in Python 2.2 (December 2001), but the blogosphere has a long memory. Since then, =lambda= is embarrassing only because of its limited syntax.

*Python Decorators and the Decorator Design Pattern*

Python function decorators fit the general description of Decorator given by Gamma et al. in /Design Patterns/: “Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.”

At the implementation level, Python decorators do not resemble the classic Decorator design pattern, but an analogy can be made.

In the design pattern, =Decorator= and =Component= are abstract classes. An instance of a concrete decorator wraps an instance of a concrete component in order to add behaviors to it. Quoting from /Design Patterns/:

#+BEGIN_QUOTE
  The decorator conforms to the interface of the component it decorates so that its presence is transparent to the component's clients. The decorator forwards requests to the component and may perform additional actions (such as drawing a border) before or after forwarding. Transparency lets you nest decorators recursively, thereby allowing an unlimited number of added responsibilities.” (p. 175)
#+END_QUOTE

In Python, the decorator function plays the role of a concrete =Decorator= subclass, and the inner function it returns is a decorator instance. The returned function wraps the function to be decorated, which is analogous to the component in the design pattern. The returned function is transparent because it conforms to the interface of the component by accepting the same arguments. It forwards calls to the component and may perform additional actions either before or after it. Borrowing from the previous citation, we can adapt the last sentence to say that “Transparency lets you nest decorators recursively, thereby allowing an unlimited number of added behaviors.” That is what enable stacked decorators to work.

Note that I am not suggesting that function decorators should be used to implement the Decorator pattern in Python programs. Although this can be done in specific situations, in general the Decorator pattern is best implemented with classes to represent the Decorator and the components it will wrap.



--------------


^{[[[#id570923][39]]]} That's the 1995 /Design Patterns/ book by the so-called Gang of Four.


^{[[[#id717907][40]]]} Python also supports class decorators. They are covered in [[file:ch21.html][Chapter 21]].


^{[[[#id756973][41]]]} This is what is meant by the term single-dispatch. If more arguments were used to select the specific functions, we'd have multiple-dispatch.


EGIN_QUOTE
  The decorator conforms to the interface of the component it decorates so that its presence is transparent to the component's clients. The decorator forwards requests to the component and may perform additional actions (such as drawing a border) before or after forwarding. Transparency lets you nest decorators recursively, thereby allowing an unlimited number of added responsibilities.” (p. 175)
#+END_QUOTE

In Python, the decorator function plays the role of a concrete =Decorator= subclass, and the inner function it returns is a decorator instance. The returned function wraps the function to be decorated, which is analogous to the component in the design pattern. The returned function is transparent because it conforms to the interface of the component by accepting the same arguments. It forwards calls to the component and may perform additional actions either before or after it. Borrowing from the previous citation, we can adapt the last sentence to say that “Transparency lets you nest decorators recursively, thereby allowing an unlimited number of added behaviors.” That is what enable stacked decorators to work.

Note that I am not suggesting that function decorators should be used to implement the Decorator pattern in Python programs. Although this can be done in specific situations, in general the Decorator pattern is best implemented with classes to represent the Decorator and the components it will wrap.



--------------


^{[[[#id570923][39]]]} That's the 1995 /Design Patterns/ book by the so-called Gang of Four.


^{[[[#id717907][40]]]} Python also supports class decorators. They are covered in [[file:ch21.html][Chapter 21]].


^{[[[#id756973][41]]]} This is what is meant by the term single-dispatch. If more arguments were used to select the specific functions, we'd have multiple-dispatch.


pecific functions, we'd have multiple-dispatch.


