* Chapter 8. Object References, Mutability, and Recycling

#+BEGIN_QUOTE
  ‘You are sad,' the Knight said in an anxious tone: ‘let me sing you a song to comfort you. [...] The name of the song is called “HADDOCKS' EYES”.'

  ‘Oh, that's the name of the song, is it?' Alice said, trying to feel interested.

  ‘No, you don't understand,' the Knight said, looking a little vexed. ‘That's what the name is CALLED. The name really IS “THE AGED AGED MAN."' (adapted from Chapter VIII. ‘It's my own Invention').

  --- Lewis Carroll /Through the Looking-Glass, and What Alice Found There/

#+END_QUOTE

Alice and the Knight set the tone of what we will see in this chapter. The theme is the distinction between objects and their names. A name is not the object; a name is a separate thing.

We start the chapter by presenting a metaphor for variables in Python: variables are labels, not boxes. If reference variables are old news to you, the analogy may still be handy if you need to explain aliasing issues to others.

We then discuss the concepts of object identity, value, and aliasing. A surprising trait of tuples is revealed: they are immutable but their values may change. This leads to a discussion of shallow and deep copies. References and function parameters are our next theme: the problem with mutable parameter defaults and the safe handling of mutable arguments passed by clients of our functions.

The last sections of the chapter cover garbage collection, the =del= command, and how to use weak references to “remember” objects without keeping them alive.

This is a rather dry chapter, but its topics lie at the heart of many subtle bugs in real Python programs.

Let's start by unlearning that a variable is like a box where you store data.

** Variables Are Not Boxes


In 1997, I took a summer course on Java at MIT. The professor, Lynn Andrea Stein---an award-winning computer science educator who currently teaches at Olin College of Engineering---made the point that the usual “variables as boxes” metaphor actually hinders the understanding of reference variables in OO languages. Python variables are like reference variables in Java, so it's better to think of them as labels attached to objects.

[[file:ch08.html#ex_a_b_refs][Example 8-1]] is a simple interaction that the “variables as boxes” idea cannot explain. [[file:ch08.html#var-boxes-x-labels][Figure 8-1]] illustrates why the box metaphor is wrong for Python, while sticky notes provide a helpful picture of how variables actually work.



Example 8-1. Variables a and b hold references to the same list, not copies of the list

#+BEGIN_EXAMPLE
    >>> a = [1, 2, 3]
    >>> b = a
    >>> a.append(4)
    >>> b
    [1, 2, 3, 4]
#+END_EXAMPLE



[[file:images/flup_0801.png.jpg]]

Figure 8-1. If you imagine variables are like boxes, you can't make sense of assignment in Python; instead, think of variables as sticky notes---[[file:ch08.html#ex_a_b_refs][Example 8-1]] then becomes easy to explain

Prof. Stein also spoke about assignment in a very deliberate way. For example, when talking about a seesaw object in a simulation, she would say: “Variable /s/ is assigned to the seesaw,” but never “The seesaw is assigned to variable /s/.” With reference variables, it makes much more sense to say that the variable is assigned to an object, and not the other way around. After all, the object is created before the assignment. [[file:ch08.html#ex_var_assign_after][Example 8-2]] proves that the righthand side of an assignment happens first.



Example 8-2. Variables are assigned to objects only after the objects are created

#+BEGIN_EXAMPLE
    >>> class Gizmo:
    ...    def __init__(self):
    ...         print('Gizmo id: %d' % id(self))
    ...
    >>> x = Gizmo()
    Gizmo id: 4301489152  
    >>> y = Gizmo() * 10  
    Gizmo id: 4301489432  
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: unsupported operand type(s) for *: 'Gizmo' and 'int'
    >>>
    >>> dir()  
    ['Gizmo', '__builtins__', '__doc__', '__loader__', '__name__',
    '__package__', '__spec__', 'x']
#+END_EXAMPLE

- [[#CO81-1][[[file:callouts/1.png]]]]  :: The output =Gizmo id: ...= is a side effect of creating a =Gizmo= instance.

- [[#CO81-2][[[file:callouts/2.png]]]]  :: Multiplying a =Gizmo= instance will raise an exception.

- [[#CO81-3][[[file:callouts/3.png]]]]  :: Here is proof that a second =Gizmo= was actually instantiated before the multiplication was attempted.

- [[#CO81-4][[[file:callouts/4.png]]]]  :: But variable =y= was never created, because the exception happened while the right-hand side of the assignment was being evaluated.

*** Tip


Never depend on =str= or =int= interning! Always use ==== and not =is= to compare them for equality. Interning is a feature for internal use of the Python interpreter.

The tricks discussed in this section, including the behavior of =frozenset.copy()=, are “white lies”; they save memory and make the interpreter faster. Do not worry about them, they should not give you any trouble because they only apply to immutable types. Probably the best use of these bits of trivia is to win bets with fellow Pythonistas.

** Chapter Summary


Every Python object has an identity, a type, and a value. Only the value of an object changes over time.^{[[[#ftn.id791035][48]]]}

If two variables refer to immutable objects that have equal values (=a == b= is =True=), in practice it rarely matters if they refer to copies or are aliases referring to the same object because the value of an immutable object does not change, with one exception. The exception is immutable collections such as tuples and frozensets: if an immutable collection holds references to mutable items, then its value may actually change when the value of a mutable item changes. In practice, this scenario is not so common. What never changes in an immutable collection are the identities of the objects within.

The fact that variables hold references has many practical consequences in Python programming:

- Simple assignment does not create copies.
- Augmented assignment with =+== or =*== creates new objects if the lefthand variable is bound to an immutable object, but may modify a mutable object in place.
- Assigning a new value to an existing variable does not change the object previously bound to it. This is called a rebinding: the variable is now bound to a different object. If that variable was the last reference to the previous object, that object will be garbage collected.
- Function parameters are passed as aliases, which means the function may change any mutable object received as an argument. There is no way to prevent this, except making local copies or using immutable objects (e.g., passing a tuple instead of a list).
- Using mutable objects as default values for function parameters is dangerous because if the parameters are changed in place, then the default is changed, affecting every future call that relies on the default.

In CPython, objects are discarded as soon as the number of references to them reaches zero. They may also be discarded if they form groups with cyclic references but no outside references. In some situations, it may be useful to hold a reference to an object that will not---by itself---keep an object alive. One example is a class that wants to keep track of all its current instances. This can be done with weak references, a low-level mechanism underlying the more useful collections =WeakValueDictionary=, =WeakKeyDictionary=, =WeakSet=, and the =finalize= function from the =weakref= module.

** Further Reading


The [[http://bit.ly/1GsZwss][“Data Model” chapter]] of /The Python Language Reference/ starts with a clear explanation of object identities and values.

Wesley Chun, author of the /Core Python/ series of books, made a great presentation about many of the topics covered in this chapter during OSCON 2013. You can download the slides from the [[http://bit.ly/1GsZvEO][“Python 103: Memory Model & Best Practices” talk page]]. There is also a [[http://bit.ly/1HGCayS][YouTube video]] of a longer presentation Wesley gave at EuroPython 2011, covering not only the theme of this chapter but also the use of special methods.

Doug Hellmann wrote a long series of excellent blog posts titled [[http://pymotw.com][Python Module of the Week]], which became a book, [[http://bit.ly/py-libex][/The Python Standard Library by Example/]]. His posts [[http://pymotw.com/2/copy/][“copy -- Duplicate Objects”]] and [[http://pymotw.com/2/weakref/][“weakref -- Garbage-Collectable References to Objects”]] cover some of the topics we just discussed.

More information on the CPython generational garbage collector can be found in the [[http://bit.ly/1HGCbmj][gc module documentation]], which starts with the sentence “This module provides an interface to the optional garbage collector.” The “optional” qualifier here may be surprising, but the [[http://bit.ly/1GsZwss][“Data Model” chapter]] also states:

#+BEGIN_QUOTE
  An implementation is allowed to postpone garbage collection or omit it altogether---it is a matter of implementation quality how garbage collection is implemented, as long as no objects are collected that are still reachable.
#+END_QUOTE

Fredrik Lundh---creator of key libraries like ElementTree, Tkinter, and the PIL image library---has a short post about the Python garbage collector titled [[http://bit.ly/1FSDBpM][“How Does Python Manage Memory?”]] He emphasizes that the garbage collector is an implementation feature that behaves differently across Python interpreters. For example, Jython uses the Java garbage collector.

The CPython 3.4 garbage collector improved handling of objects with a =__del__= method, as described in [[http://bit.ly/1HGCde7][PEP 442 --- Safe object finalization]].

Wikipedia has an article about [[http://bit.ly/1HGCduC][string interning]], mentioning the use of this technique in several languages, including Python.

Soapbox

*Equal Treatment to All Objects*

I learned Java before I discovered Python. The ==== operator in Java never felt right for me. It is much more common for programmers to care about equality than identity, but for objects (not primitive types) the Java ==== compares references, and not object values. Even for something as basic as comparing strings, Java forces you to use the =.equals= method. Even then, there is another catch: if you write =a.equals(b)= and =a= is =null=, you get a null pointer exception. The Java designers felt the need to overload =+= for strings, so why not go ahead and overload ==== as well?

Python gets this right. The ==== operator compares object values and =is= compares references. And because Python has operator overloading, ==== works sensibly with all objects in the standard library, including =None=, which is a proper object, unlike Java's =null=.

And of course, you can define =__eq__= in your own classes to decide what ==== means for your instances. If you don't override =__eq__=, the method inherited from =object= compares object IDs, so the fallback is that every instance of a user-defined class is considered different.

These are some of the things that made me switch from Java to Python as soon as I finished reading the Python Tutorial one afternoon in September 1998.

*Mutability*

This chapter would be redundant if all Python objects were immutable. When you are dealing with unchanging objects, it makes no difference whether variables hold the actual objects or references to shared objects. If =a == b= is true, and neither object can change, they might as well be the same. That's why string interning is safe. Object identity becomes important only when objects are mutable.

In “pure” functional programming, all data is immutable: appending to a collection actually creates a new collection. Python, however, is not a functional language, much less a pure one. Instances of user-defined classes are mutable by default in Python---as in most object-oriented languages. When creating your own objects, you have to be extra careful to make them immutable, if that is a requirement. Every attribute of the object must also be immutable, otherwise you end up with something like the =tuple=: immutable as far as object IDs go, but the value of a =tuple= may change if it holds a mutable object.

Mutable objects are also the main reason why programming with threads is so hard to get right: threads mutating objects without proper synchronization produce corrupted data. Excessive synchronization, on the other hand, causes deadlocks.

*Object Destruction and Garbage Collection*

There is no mechanism in Python to directly destroy an object, and this omission is actually a great feature: if you could destroy an object at any time, what would happen to existing strong references pointing to it?

Garbage collection in CPython is done primarily by reference counting, which is easy to implement, but is prone to memory leaking when there are reference cycles, so with version 2.0 (October 2000) a generational garbage collector was implemented, and it is able to dispose of unreachable objects kept alive by reference cycles.

But the reference counting is still there as a baseline, and it causes the immediate disposal of objects with zero references. This means that, in CPython---at least for now---it's safe to write this:

#+BEGIN_EXAMPLE
    open('test.txt', 'wt', encoding='utf-8').write('1, 2, 3')
#+END_EXAMPLE

That code is safe because the reference count of the file object will be zero after the =write= method returns, and Python will immediately close the file before destroying the object representing it in memory. However, the same line is not safe in Jython or IronPython that use the garbage collector of their host runtimes (the Java VM and the .NET CLR), which are more sophisticated but do not rely on reference counting and may take longer to destroy the object and close the file. In all cases, including CPython, the best practice is to explicitly close the file, and the most reliable way of doing it is using the =with= statement, which guarantees that the file will be closed even if exceptions are raised while it is open. Using =with=, the previous snippet becomes:

#+BEGIN_EXAMPLE
    with open('test.txt', 'wt', encoding='utf-8') as fp:
        fp.write('1, 2, 3')
#+END_EXAMPLE

If you are into the subject of garbage collectors, you may want to read Thomas Perl's paper [[http://bit.ly/1Gt0HrJ][“Python Garbage Collector Implementations: CPython, PyPy and GaS”]], from which I learned the bit about the safety of the =open().write()= in CPython.

*Parameter Passing: Call by Sharing*

A popular way of explaining how parameter passing works in Python is the phrase: “Parameters are passed by value, but the values are references.” This not wrong, but causes confusion because the most common parameter passing modes in older languages are /call by value/ (the function gets a copy of the argument) and /call by reference/ (the function gets a pointer to the argument). In Python, the function gets a copy of the arguments, but the arguments are always references. So the value of the referenced objects may be changed, if they are mutable, but their identity cannot. Also, because the function gets a copy of the reference in an argument, rebinding it has no effect outside of the function. I adopted the term /call by sharing/ after reading up on the subject in /Programming Language Pragmatics, Third Edition/ by Michael L. Scott (Morgan Kaufmann), particularly “8.3.1: Parameter Modes.”

*The Full Quote of Alice and the Knights's Song*

I love this passage, but it was too long as a chapter opener. So here is the complete dialog about the Knight's song, its name, and how the song and its name are called:

#+BEGIN_QUOTE
  ‘You are sad,' the Knight said in an anxious tone: ‘let me sing you a song to comfort you.'

  ‘Is it very long?' Alice asked, for she had heard a good deal of poetry that day.

  ‘It's long,' said the Knight, ‘but very, VERY beautiful. Everybody that hears me sing it---either it brings the TEARS into their eyes, or else---'

  ‘Or else what?' said Alice, for the Knight had made a sudden pause.

  ‘Or else it doesn't, you know. The name of the song is called “HADDOCKS' EYES”.'

  ‘Oh, that's the name of the song, is it?' Alice said, trying to feel interested.

  ‘No, you don't understand,' the Knight said, looking a little vexed. ‘That's what the name is CALLED. The name really IS “THE AGED AGED MAN”.'

  ‘Then I ought to have said “That's what the SONG is called”?' Alice corrected herself.

  ‘No, you oughtn't: that's quite another thing! The SONG is called “WAYS AND MEANS”: but that's only what it's CALLED, you know!'

  ‘Well, what IS the song, then?' said Alice, who was by this time completely bewildered.

  ‘I was coming to that,' the Knight said. ‘The song really IS “A-SITTING ON A GATE”: and the tune's my own invention.'

  --- Lewis Carroll /Chapter VIII, “It's My Own Invention,” Through the Looking-Glass/

#+END_QUOTE



--------------


^{[[[#id934635][42]]]} On the other hand, single-type sequences like =str=, =bytes=, and =array.array= are flat: they don't contain references but physically hold their data---characters, bytes, and numbers---in contiguous memory.


^{[[[#id841297][43]]]} If two objects refer to each other, as in [[file:ch08.html#ex_cycle1][Example 8-10]], they may be destroyed if the garbage collector determines that they are otherwise unreachable because their only references are their mutual references.


^{[[[#id568824][44]]]} =cheeseshop.python.org= is also an alias for PyPI---the Python Package Index software repository---which started its life quite empty. At the time of this writing, the Python Cheese Shop has 41,426 packages. Not bad, but still far from the more than 131,000 modules available in CPAN---the Comprehensive Perl Archive Network---the envy of all dynamic language communities.


^{[[[#id784062][45]]]} Parmesan cheese is aged at least a year at the factory, so it is more durable than fresh cheese, but this is not the answer we are looking for.


^{[[[#id732475][46]]]} This is clearly documented. Type =help(tuple)= in the Python console to read: “If the argument is a tuple, the return value is the same object.” I thought I knew everything about tuples before writing this book.


^{[[[#id870346][47]]]} The white lie of having the =copy= method not copying anything can be explained by interface compatibility: it makes =frozenset= more compatible with =set=. Anyway, it makes no difference to the end user whether two identical immutable objects are the same or are copies.


^{[[[#id791035][48]]]} Actually the type of an object may be changed by merely assigning a different class to its =__class__= attribute, but that is pure evil and I regret writing this footnote.


be destroyed if the garbage collector determines that they are otherwise unreachable because their only references are their mutual references.


^{[[[#id568824][44]]]} =cheeseshop.python.org= is also an alias for PyPI---the Python Package Index software repository---which started its life quite empty. At the time of this writing, the Python Cheese Shop has 41,426 packages. Not bad, but still far from the more than 131,000 modules available in CPAN---the Comprehensive Perl Archive Network---the envy of all dynamic language communities.


^{[[[#id784062][45]]]} Parmesan cheese is aged at least a year at the factory, so it is more durable than fresh cheese, but this is not the answer we are looking for.


^{[[[#id732475][46]]]} This is clearly documented. Type =help(tuple)= in the Python console to read: “If the argument is a tuple, the return value is the same object.” I thought I knew everything about tuples before writing this book.


^{[[[#id870346][47]]]} The white lie of having the =copy= method not copying anything can be explained by interface compatibility: it makes =frozenset= more compatible with =set=. Anyway, it makes no difference to the end user whether two identical immutable objects are the same or are copies.


^{[[[#id791035][48]]]} Actually the type of an object may be changed by merely assigning a different class to its =__class__= attribute, but that is pure evil and I regret writing this footnote.


class__= attribute, but that is pure evil and I regret writing this footnote.


blem of using mutable types as parameter defaults. These issues will be covered next.

** Function Parameters as References


The only mode of parameter passing in Python is /call by sharing/. That is the same mode used in most OO languages, including Ruby, SmallTalk, and Java (this applies to Java reference types; primitive types use call by value). Call by sharing means that each formal parameter of the function gets a copy of each reference in the arguments. In other words, the parameters inside the function become aliases of the actual arguments.

The result of this scheme is that a function may change any mutable object passed as a parameter, but it cannot change the identity of those objects (i.e., it cannot altogether replace an object with another). [[file:ch08.html#ex_param_pass][Example 8-11]] shows a simple function using =+== on one of its parameters. As we pass numbers, lists, and tuples to the function, the actual arguments passed are affected in different ways.



Example 8-11. A function may change any mutable object it receives

#+BEGIN_EXAMPLE
    >>> def f(a, b):
    ...     a += b
    ...     return a
    ...
    >>> x = 1
    >>> y = 2
    >>> f(x, y)
    3
    >>> x, y  
    (1, 2)
    >>> a = [1, 2]
    >>> b = [3, 4]
    >>> f(a, b)
    [1, 2, 3, 4]
    >>> a, b  
    ([1, 2, 3, 4], [3, 4])
    >>> t = (10, 20)
    >>> u = (30, 40)
    >>> f(t, u)  
    (10, 20, 30, 40)
    >>> t, u
    ((10, 20), (30, 40))
#+END_EXAMPLE

- [[#CO88-1][[[file:callouts/1.png]]]]  :: The number =x= is unchanged.

- [[#CO88-2][[[file:callouts/2.png]]]]  :: The list =a= is changed.

- [[#CO88-3][[[file:callouts/3.png]]]]  :: The tuple =t= is unchanged.

Another issue related to function parameters is the use of mutable values for defaults, as discussed next.

*** Mutable Types as Parameter Defaults: Bad Idea
    :PROPERTIES:
    :CUSTOM_ID: _mutable_types_as_parameter_defaults_bad_idea
    :CLASS: title
    :END:

Optional parameters with default values are a great feature of Python function definitions, allowing our APIs to evolve while remaining backward-compatible. However, you should avoid mutable objects as default values for parameters.

To illustrate this point, in [[file:ch08.html#ex_haunted_bus][Example 8-12]], we take the =Bus= class from [[file:ch08.html#ex_bus1][Example 8-8]] and change its =__init__= method to create =HauntedBus=. Here we tried to be clever and instead of having a default value of =passengers=None=, we have =passengers=[]=, thus avoiding the =if= in the previous =__init__=. This “cleverness” gets us into trouble.



Example 8-12. A simple class to illustrate the danger of a mutable default

#+BEGIN_EXAMPLE
    class HauntedBus:
        """A bus model haunted by ghost passengers"""

        def __init__(self, passengers=[]):   
            self.passengers = passengers   

        def pick(self, name):
            self.passengers.append(name)   

        def drop(self, name):
            self.passengers.remove(name)
#+END_EXAMPLE

- [[#CO89-1][[[file:callouts/1.png]]]]  :: When the =passengers= argument is not passed, this parameter is bound to the default list object, which is initially empty.

- [[#CO89-2][[[file:callouts/2.png]]]]  :: This assignment makes =self.passengers= an alias for =passengers=, which is itself an alias for the default list, when no =passengers= argument is given.

- [[#CO89-3][[[file:callouts/3.png]]]]  :: When the methods =.remove()= and =.append()= are used with =self.passengers= we are actually mutating the default list, which is an attribute of the function object.

[[file:ch08.html#demo_haunted_bus][Example 8-13]] shows the eerie behavior of the =HauntedBus=.



Example 8-13. Buses haunted by ghost passengers

#+BEGIN_EXAMPLE
    >>> bus1 = HauntedBus(['Alice', 'Bill'])
    >>> bus1.passengers
    ['Alice', 'Bill']
    >>> bus1.pick('Charlie')
    >>> bus1.drop('Alice')
    >>> bus1.passengers  
    ['Bill', 'Charlie']
    >>> bus2 = HauntedBus()  
    >>> bus2.pick('Carrie')
    >>> bus2.passengers
    ['Carrie']
    >>> bus3 = HauntedBus()  
    >>> bus3.passengers  
    ['Carrie']
    >>> bus3.pick('Dave')
    >>> bus2.passengers  
    ['Carrie', 'Dave']
    >>> bus2.passengers is bus3.passengers  
    True
    >>> bus1.passengers  
    ['Bill', 'Charlie']
#+END_EXAMPLE

- [[#CO90-1][[[file:callouts/1.png]]]]  :: So far, so good: no surprises with =bus1=.

- [[#CO90-2][[[file:callouts/2.png]]]]  :: =bus2= starts empty, so the default empty list is assigned to =self.passengers=.

- [[#CO90-3][[[file:callouts/3.png]]]]  :: =bus3= also starts empty, again the default list is assigned.

- [[#CO90-4][[[file:callouts/4.png]]]]  :: The default is no longer empty!

- [[#CO90-5][[[file:callouts/5.png]]]]  :: Now =Dave=, picked by =bus3=, appears in =bus2=.

- [[#CO90-6][[[file:callouts/6.png]]]]  :: The problem: =bus2.passengers= and =bus3.passengers= refer to the same list.

- [[#CO90-7][[[file:callouts/7.png]]]]  :: But =bus1.passengers= is a distinct list.

The problem is that =Bus= instances that don't get an initial passenger list end up sharing the same passenger list among themselves.

Such bugs may be subtle. As [[file:ch08.html#demo_haunted_bus][Example 8-13]] demonstrates, when a =HauntedBus= is instantiated with passengers, it works as expected. Strange things happen only when a =HauntedBus= starts empty, because then =self.passengers= becomes an alias for the default value of the =passengers= parameter. The problem is that each default value is evaluated when the function is defined---i.e., usually when the module is loaded---and the default values become attributes of the function object. So if a default value is a mutable object, and you change it, the change will affect every future call of the function.

After running the lines in [[file:ch08.html#demo_haunted_bus][Example 8-13]], you can inspect the =HauntedBus.__init__= object and see the ghost students haunting its =__defaults__= attribute:

#+BEGIN_EXAMPLE
    >>> dir(HauntedBus.__init__)  # doctest: +ELLIPSIS
    ['__annotations__', '__call__', ..., '__defaults__', ...]
    >>> HauntedBus.__init__.__defaults__
    (['Carrie', 'Dave'],)
#+END_EXAMPLE

Finally, we can verify that =bus2.passengers= is an alias bound to the first element of the =HauntedBus.__init__.__defaults__= attribute:

#+BEGIN_EXAMPLE
    >>> HauntedBus.__init__.__defaults__[0] is bus2.passengers
    True
#+END_EXAMPLE

The issue with mutable defaults explains why =None= is often used as the default value for parameters that may receive mutable values. In [[file:ch08.html#ex_bus1][Example 8-8]], =__init__= checks whether the =passengers= argument is =None=, and assigns a new empty list to =self.passengers=. As explained in the following section, if =passengers= is not =None=, the correct implementation assigns a copy of it to =self.passengers=. Let's now take a closer look.

*** Defensive Programming with Mutable Parameters
    :PROPERTIES:
    :CUSTOM_ID: defensive_argument
    :CLASS: title
    :END:

When you are coding a function that receives a mutable parameter, you should carefully consider whether the caller expects the argument passed to be changed.

For example, if your function receives a =dict= and needs to modify it while processing it, should this side effect be visible outside of the function or not? Actually it depends on the context. It's really a matter of aligning the expectation of the coder of the function and that of the caller.

The last bus example in this chapter shows how a =TwilightBus= breaks expectations by sharing its passenger list with its clients. Before studying the implementation, see in [[file:ch08.html#demo_twilight_bus][Example 8-14]] how the =TwilightBus= class works from the perspective of a client of the class.



Example 8-14. Passengers disappear when dropped by a TwilightBus

#+BEGIN_EXAMPLE
    >>> basketball_team = ['Sue', 'Tina', 'Maya', 'Diana', 'Pat']  
    >>> bus = TwilightBus(basketball_team)  
    >>> bus.drop('Tina')  
    >>> bus.drop('Pat')
    >>> basketball_team  
    ['Sue', 'Maya', 'Diana']
#+END_EXAMPLE

- [[#CO91-1][[[file:callouts/1.png]]]]  :: =basketball_team= holds five student names.

- [[#CO91-2][[[file:callouts/2.png]]]]  :: A =TwilightBus= is loaded with the team.

- [[#CO91-3][[[file:callouts/3.png]]]]  :: The =bus= drops one student, then another.

- [[#CO91-4][[[file:callouts/4.png]]]]  :: The dropped passengers vanished from the basketball team!

=TwilightBus= violates the “Principle of least astonishment,” a best practice of interface design. It surely is astonishing that when the bus drops a student, her name is removed from the basketball team roster.

[[file:ch08.html#ex_twilight_bus][Example 8-15]] is the implementation =TwilightBus= and an explanation of the problem.



Example 8-15. A simple class to show the perils of mutating received arguments

#+BEGIN_EXAMPLE
    class TwilightBus:
        """A bus model that makes passengers vanish"""

        def __init__(self, passengers=None):
            if passengers is None:
                self.passengers = []   
            else:
                self.passengers = passengers  

        def pick(self, name):
            self.passengers.append(name)

        def drop(self, name):
            self.passengers.remove(name)   
#+END_EXAMPLE

- [[#CO92-1][[[file:callouts/1.png]]]]  :: Here we are careful to create a new empty list when =passengers= is =None=.

- [[#CO92-2][[[file:callouts/2.png]]]]  :: However, this assignment makes =self.passengers= an alias for =passengers=, which is itself an alias for the actual argument passed to =__init__= (i.e.,=basketball_team= in [[file:ch08.html#demo_twilight_bus][Example 8-14]]).

- [[#CO92-3][[[file:callouts/3.png]]]]  :: When the methods =.remove()= and =.append()= are used with =self.passengers=, we are actually mutating the original list received as argument to the constructor.

The problem here is that the bus is aliasing the list that is passed to the constructor. Instead, it should keep its own passenger list. The fix is simple: in =__init__=, when the =passengers= parameter is provided, =self.passengers= should be initialized with a copy of it, as we did correctly in [[file:ch08.html#ex_bus1][Example 8-8]] ([[file:ch08.html#deep_x_shallow_copies][Deep and Shallow Copies of Arbitrary Objects]]):

#+BEGIN_EXAMPLE
        def __init__(self, passengers=None):
            if passengers is None:
                self.passengers = []
            else:
                self.passengers = list(passengers) 
#+END_EXAMPLE

- [[#CO93-1][[[file:callouts/1.png]]]]  :: Make a copy of the =passengers= list, or convert it to a =list= if it's not one.

Now our internal handling of the passenger list will not affect the argument used to initialize the bus. As a bonus, this solution is more flexible: now the argument passed to the =passengers= parameter may be a =tuple= or any other iterable, like a =set= or even database results, because the =list= constructor accepts any iterable. As we create our own list to manage, we ensure that it supports the necessary =.remove()= and =.append()= operations we use in the =.pick()= and =.drop()= methods.

*** Tip
    :PROPERTIES:
    :CUSTOM_ID: tip-2
    :CLASS: title
    :END:

Unless a method is explicitly intended to mutate an object received as argument, you should think twice before aliasing the argument object by simply assigning it to an instance variable in your class. If in doubt, make a copy. Your clients will often be happier.

** del and Garbage Collection


#+BEGIN_QUOTE
  Objects are never explicitly destroyed; however, when they become unreachable they may be garbage-collected.

  --- “Data Model” chapter of /The Python Language Reference/

#+END_QUOTE

The =del= statement deletes names, not objects. An object may be garbage collected as result of a =del= command, but only if the variable deleted holds the last reference to the object, or if the object becomes unreachable.^{[[[#ftn.id841297][43]]]} Rebinding a variable may also cause the number of references to an object to reach zero, causing its destruction.

*** Warning
    :PROPERTIES:
    :CUSTOM_ID: warning
    :CLASS: title
    :END:

There is a =__del__= special method, but it does not cause the disposal of the instance, and should not be called by your code. =__del__= is invoked by the Python interpreter when the instance is about to be destroyed to give it a chance to release external resources. You will seldom need to implement =__del__= in your own code, yet some Python beginners spend time coding it for no good reason. The proper use of =__del__= is rather tricky. See the [[http://bit.ly/1GsWPac][=__del__= special method documentation]] in the “Data Model” chapter of /The Python Language Reference/.

In CPython, the primary algorithm for garbage collection is reference counting. Essentially, each object keeps count of how many references point to it. As soon as that /refcount/ reaches zero, the object is immediately destroyed: CPython calls the =__del__= method on the object (if defined) and then frees the memory allocated to the object. In CPython 2.0, a generational garbage collection algorithm was added to detect groups of objects involved in reference cycles---which may be unreachable even with outstanding references to them, when all the mutual references are contained within the group. Other implementations of Python have more sophisticated garbage collectors that do not rely on reference counting, which means the =__del__= method may not be called immediately when there are no more references to the object. See [[http://bit.ly/1GsWTa7][“PyPy, Garbage Collection, and a Deadlock”]] by A. Jesse Jiryu Davis for discussion of improper and proper use of =__del__=.

To demonstrate the end of an object's life, [[file:ch08.html#ex_finalize][Example 8-16]] uses =weakref.finalize= to register a callback function to be called when an object is destroyed.



Example 8-16. Watching the end of an object when no more references point to it

#+BEGIN_EXAMPLE
    >>> import weakref
    >>> s1 = {1, 2, 3}
    >>> s2 = s1         
    >>> def bye():      
    ...     print('Gone with the wind...')
    ...
    >>> ender = weakref.finalize(s1, bye)  
    >>> ender.alive  
    True
    >>> del s1
    >>> ender.alive  
    True
    >>> s2 = 'spam'  
    Gone with the wind...
    >>> ender.alive
    False
#+END_EXAMPLE

- [[#CO94-1][[[file:callouts/1.png]]]]  :: =s1= and =s2= are aliases referring to the same set, ={1, 2, 3}=.

- [[#CO94-2][[[file:callouts/2.png]]]]  :: This function must not be a bound method of the object about to be destroyed or otherwise hold a reference to it.

- [[#CO94-3][[[file:callouts/3.png]]]]  :: Register the =bye= callback on the object referred by =s1=.

- [[#CO94-4][[[file:callouts/4.png]]]]  :: The =.alive= attribute is =True= before the =finalize= object is called.

- [[#CO94-5][[[file:callouts/5.png]]]]  :: As discussed, =del= does not delete an object, just a reference to it.

- [[#CO94-6][[[file:callouts/6.png]]]]  :: Rebinding the last reference, =s2=, makes ={1, 2, 3}= unreachable. It is destroyed, the =bye= callback is invoked, and =ender.alive= becomes =False=.

The point of [[file:ch08.html#ex_finalize][Example 8-16]] is to make explicit that =del= does not delete objects, but objects may be deleted as a consequence of being unreachable after =del= is used.

You may be wondering why the ={1, 2, 3}= object was destroyed in [[file:ch08.html#ex_finalize][Example 8-16]]. After all, the =s1= reference was passed to the =finalize= function, which must have held on to it in order to monitor the object and invoke the callback. This works because =finalize= holds a /weak reference/ to ={1, 2, 3}=, as explained in the next section.

** Weak References


The presence of references is what keeps an object alive in memory. When the reference count of an object reaches zero, the garbage collector disposes of it. But sometimes it is useful to have a reference to an object that does not keep it around longer than necessary. A common use case is a cache.

Weak references to an object do not increase its reference count. The object that is the target of a reference is called the /referent/. Therefore, we say that a weak reference does not prevent the referent from being garbage collected.

Weak references are useful in caching applications because you don't want the cached objects to be kept alive just because they are referenced by the cache.

[[file:ch08.html#ex_weakref_ref][Example 8-17]] shows how a =weakref.ref= instance can be called to reach its referent. If the object is alive, calling the weak reference returns it, otherwise =None= is returned.

*** Tip
    :PROPERTIES:
    :CUSTOM_ID: tip-3
    :CLASS: title
    :END:

[[file:ch08.html#ex_weakref_ref][Example 8-17]] is a console session, and the Python console automatically binds the =_= variable to the result of expressions that are not =None=. This interfered with my intended demonstration but also highlights a practical matter: when trying to micro-manage memory we are often surprised by hidden, implicit assignments that create new references to our objects. The =_= console variable is one example. Traceback objects are another common source of unexpected references.



Example 8-17. A weak reference is a callable that returns the referenced object or None if the referent is no more

#+BEGIN_EXAMPLE
    >>> import weakref
    >>> a_set = {0, 1}
    >>> wref = weakref.ref(a_set)  
    >>> wref
    <weakref at 0x100637598; to 'set' at 0x100636748>
    >>> wref()  
    {0, 1}
    >>> a_set = {2, 3, 4}  
    >>> wref()  
    {0, 1}
    >>> wref() is None  
    False
    >>> wref() is None  
    True
#+END_EXAMPLE

- [[#CO95-1][[[file:callouts/1.png]]]]  :: The =wref= weak reference object is created and inspected in the next line.

- [[#CO95-2][[[file:callouts/2.png]]]]  :: Invoking =wref()= returns the referenced object, ={0, 1}=. Because this is a console session, the result ={0, 1}= is bound to the =_= variable.

- [[#CO95-3][[[file:callouts/3.png]]]]  :: =a_set= no longer refers to the ={0, 1}= set, so its reference count is decreased. But the =_= variable still refers to it.

- [[#CO95-4][[[file:callouts/4.png]]]]  :: Calling =wref()= still returns ={0, 1}=.

- [[#CO95-5][[[file:callouts/5.png]]]]  :: When this expression is evaluated, ={0, 1}= lives, therefore =wref()= is not =None=. But =_= is then bound to the resulting value, =False=. Now there are no more strong references to ={0, 1}=.

- [[#CO95-6][[[file:callouts/6.png]]]]  :: Because the ={0, 1}= object is now gone, this last call to =wref()= returns =None=.

The [[http://docs.python.org/3/library/weakref.html][=weakref= module documentation]] makes the point that the =weakref.ref= class is actually a low-level interface intended for advanced uses, and that most programs are better served by the use of the =weakref= collections and =finalize=. In other words, consider using =WeakKeyDictionary=, =WeakValueDictionary=, =WeakSet=, and =finalize= (which use weak references internally) instead of creating and handling your own =weakref.ref= instances by hand. We just did that in [[file:ch08.html#ex_weakref_ref][Example 8-17]] in the hope that showing a single =weakref.ref= in action could take away some of the mystery around them. But in practice, most of the time Python programs use the =weakref= collections.

The next subsection briefly discusses the =weakref= collections.

*** The WeakValueDictionary Skit
    :PROPERTIES:
    :CUSTOM_ID: _the_weakvaluedictionary_skit
    :CLASS: title
    :END:

The class =WeakValueDictionary= implements a mutable mapping where the values are weak references to objects. When a referred object is garbage collected elsewhere in the program, the corresponding key is automatically removed from =WeakValueDictionary=. This is commonly used for caching.

Our demonstration of a =WeakValueDictionary= is inspired by the classic /Cheese Shop/ skit by Monty Python, in which a customer asks for more than 40 kinds of cheese, including cheddar and mozzarella, but none are in stock.^{[[[#ftn.id568824][44]]]}

[[file:ch08.html#ex_cheeseshop_class][Example 8-18]] implements a trivial class to represent each kind of cheese.



Example 8-18. Cheese has a kind attribute and a standard representation

#+BEGIN_EXAMPLE
    class Cheese:

        def __init__(self, kind):
            self.kind = kind

        def __repr__(self):
            return 'Cheese(%r)' % self.kind
#+END_EXAMPLE

In [[file:ch08.html#ex_cheeseshop_demo][Example 8-19]], each cheese is loaded from a =catalog= to a =stock= implemented as a =WeakValueDictionary=. However, all but one disappear from the =stock= as soon as the =catalog= is deleted. Can you explain why the Parmesan cheese lasts longer than the others?^{[[[#ftn.id784062][45]]]} The tip after the code has the answer.



Example 8-19. Customer: “Have you in fact got any cheese here at all?”

#+BEGIN_EXAMPLE
    >>> import weakref
    >>> stock = weakref.WeakValueDictionary()  
    >>> catalog = [Cheese('Red Leicester'), Cheese('Tilsit'),
    ...                 Cheese('Brie'), Cheese('Parmesan')]
    ...
    >>> for cheese in catalog:
    ...     stock[cheese.kind] = cheese  
    ...
    >>> sorted(stock.keys())
    ['Brie', 'Parmesan', 'Red Leicester', 'Tilsit']  
    >>> del catalog
    >>> sorted(stock.keys())
    ['Parmesan']  
    >>> del cheese
    >>> sorted(stock.keys())
    []
#+END_EXAMPLE

- [[#CO96-1][[[file:callouts/1.png]]]]  :: =stock= is a =WeakValueDictionary=.

- [[#CO96-2][[[file:callouts/2.png]]]]  :: The =stock= maps the name of the cheese to a weak reference to the cheese instance in the =catalog=.

- [[#CO96-3][[[file:callouts/3.png]]]]  :: The =stock= is complete.

- [[#CO96-4][[[file:callouts/4.png]]]]  :: After the =catalog= is deleted, most cheeses are gone from the =stock=, as expected in =WeakValueDictionary=. Why not all, in this case?

*** Tip
    :PROPERTIES:
    :CUSTOM_ID: tip-4
    :CLASS: title
    :END:

A temporary variable may cause an object to last longer than expected by holding a reference to it. This is usually not a problem with local variables: they are destroyed when the function returns. But in [[file:ch08.html#ex_cheeseshop_demo][Example 8-19]], the =for= loop variable =cheese= is a global variable and will never go away unless explicitly deleted.

A counterpart to the =WeakValueDictionary= is the =WeakKeyDictionary= in which the keys are weak references. The [[http://bit.ly/1GsXB6Z][=weakref.WeakKeyDictionary= documentation]] hints on possible uses:

#+BEGIN_QUOTE
  [A =WeakKeyDictionary=] can be used to associate additional data with an object owned by other parts of an application without adding attributes to those objects. This can be especially useful with objects that override attribute accesses.
#+END_QUOTE

The =weakref= module also provides a =WeakSet=, simply described in the docs as “Set class that keeps weak references to its elements. An element will be discarded when no strong reference to it exists any more.” If you need to build a class that is aware of every one of its instances, a good solution is to create a class attribute with a =WeakSet= to hold the references to the instances. Otherwise, if a regular =set= was used, the instances would never be garbage collected, because the class itself would have strong references to them, and classes live as long as the Python process unless you deliberately delete them.

These collections, and weak references in general, are limited in the kinds of objects they can handle. The next section explains.

*** Limitations of Weak References
    :PROPERTIES:
    :CUSTOM_ID: _limitations_of_weak_references
    :CLASS: title
    :END:

Not every Python object may be the target, or referent, of a weak reference. Basic =list= and =dict= instances may not be referents, but a plain subclass of either can solve this problem easily:

#+BEGIN_EXAMPLE
    class MyList(list):
        """list subclass whose instances may be weakly referenced"""

    a_list = MyList(range(10))

    # a_list can be the target of a weak reference
    wref_to_a_list = weakref.ref(a_list)
#+END_EXAMPLE

A =set= instance can be a referent, and that's why a =set= was used in [[file:ch08.html#ex_weakref_ref][Example 8-17]]. User-defined types also pose no problem, which explains why the silly =Cheese= class was needed in [[file:ch08.html#ex_cheeseshop_demo][Example 8-19]]. But =int= and =tuple= instances cannot be targets of weak references, even if subclasses of those types are created.

Most of these limitations are implementation details of CPython that may not apply to other Python iterpreters. They are the result of internal optimizations, some of which are discussed in the following (highly optional) section.

** Tricks Python Plays with Immutables


*** Note
    :PROPERTIES:
    :CUSTOM_ID: note
    :CLASS: title
    :END:

You may safely skip this section. It discusses some Python implementation details that are not really important for /users/ of Python. They are shortcuts and optimizations done by the CPython core developers, which should not bother you when using the language, and that may not apply to other Python implementations or even future versions of CPython. Nevertheless, while experimenting with aliases and copies you may stumble upon these tricks, so I felt they were worth mentioning.

I was surprised to learn that, for a tuple =t=, =t[:]= does not make a copy, but returns a reference to the same object. You also get a reference to the same tuple if you write =tuple(t)=.^{[[[#ftn.id732475][46]]]} [[file:ch08.html#ex_same_tuple][Example 8-20]] proves it.



Example 8-20. A tuple built from another is actually the same exact tuple

#+BEGIN_EXAMPLE
    >>> t1 = (1, 2, 3)
    >>> t2 = tuple(t1)
    >>> t2 is t1  
    True
    >>> t3 = t1[:]
    >>> t3 is t1  
    True
#+END_EXAMPLE

- [[#CO97-1][[[file:callouts/1.png]]]]  :: =t1= and =t2= are bound to the same object.

- [[#CO97-2][[[file:callouts/2.png]]]]  :: And so is =t3=.

The same behavior can be observed with instances of =str=, =bytes=, and =frozenset=. Note that a =frozenset= is not a sequence, so =fs[:]= does not work if =fs= is a =frozenset=. But =fs.copy()= has the same effect: it cheats and returns a reference to the same object, and not a copy at all, as [[file:ch08.html#ex_same_string][Example 8-21]] shows.^{[[[#ftn.id870346][47]]]}



Example 8-21. String literals may create shared objects

#+BEGIN_EXAMPLE
    >>> t1 = (1, 2, 3)
    >>> t3 = (1, 2, 3)  # 
    >>> t3 is t1  # 
    False
    >>> s1 = 'ABC'
    >>> s2 = 'ABC'  # 
    >>> s2 is s1 # 
    True
#+END_EXAMPLE

- [[#CO98-1][[[file:callouts/1.png]]]]  :: Creating a new tuple from scratch.

- [[#CO98-2][[[file:callouts/2.png]]]]  :: =t1= and =t3= are equal, but not the same object.

- [[#CO98-3][[[file:callouts/3.png]]]]  :: Creating a second =str= from scratch.

- [[#CO98-4][[[file:callouts/4.png]]]]  :: Surprise: =a= and =b= refer to the same =str=!

The sharing of string literals is an optimization technique called /interning/. CPython uses the same technique with small integers to avoid unnecessary duplication of “popular” numbers like 0, --1, and 42. Note that CPython does not intern all strings or integers, and the criteria it uses to do so is an undocumented implementation detail.

*** Warning
    :PROPERTIES:
    :CUSTOM_ID: warning-1
    :CLASS: title
    :END:

Never depend on =str= or =int= interning! Always use ==== and not =is= to compare them for equality. Interning is a feature for internal use of the Python interpreter.

The tricks discussed in this section, including the behavior of =frozenset.copy()=, are “white lies”; they save memory and make the interpreter faster. Do not worry about them, they should not give you any trouble because they only apply to immutable types. Probably the best use of these bits of trivia is to win bets with fellow Pythonistas.

** Chapter Summary


Every Python object has an identity, a type, and a value. Only the value of an object changes over time.^{[[[#ftn.id791035][48]]]}

If two variables refer to immutable objects that have equal values (=a == b= is =True=), in practice it rarely matters if they refer to copies or are aliases referring to the same object because the value of an immutable object does not change, with one exception. The exception is immutable collections such as tuples and frozensets: if an immutable collection holds references to mutable items, then its value may actually change when the value of a mutable item changes. In practice, this scenario is not so common. What never changes in an immutable collection are the identities of the objects within.

The fact that variables hold references has many practical consequences in Python programming:

- Simple assignment does not create copies.
- Augmented assignment with =+== or =*== creates new objects if the lefthand variable is bound to an immutable object, but may modify a mutable object in place.
- Assigning a new value to an existing variable does not change the object previously bound to it. This is called a rebinding: the variable is now bound to a different object. If that variable was the last reference to the previous object, that object will be garbage collected.
- Function parameters are passed as aliases, which means the function may change any mutable object received as an argument. There is no way to prevent this, except making local copies or using immutable objects (e.g., passing a tuple instead of a list).
- Using mutable objects as default values for function parameters is dangerous because if the parameters are changed in place, then the default is changed, affecting every future call that relies on the default.

In CPython, objects are discarded as soon as the number of references to them reaches zero. They may also be discarded if they form groups with cyclic references but no outside references. In some situations, it may be useful to hold a reference to an object that will not---by itself---keep an object alive. One example is a class that wants to keep track of all its current instances. This can be done with weak references, a low-level mechanism underlying the more useful collections =WeakValueDictionary=, =WeakKeyDictionary=, =WeakSet=, and the =finalize= function from the =weakref= module.

** Further Reading


The [[http://bit.ly/1GsZwss][“Data Model” chapter]] of /The Python Language Reference/ starts with a clear explanation of object identities and values.

Wesley Chun, author of the /Core Python/ series of books, made a great presentation about many of the topics covered in this chapter during OSCON 2013. You can download the slides from the [[http://bit.ly/1GsZvEO][“Python 103: Memory Model & Best Practices” talk page]]. There is also a [[http://bit.ly/1HGCayS][YouTube video]] of a longer presentation Wesley gave at EuroPython 2011, covering not only the theme of this chapter but also the use of special methods.

Doug Hellmann wrote a long series of excellent blog posts titled [[http://pymotw.com][Python Module of the Week]], which became a book, [[http://bit.ly/py-libex][/The Python Standard Library by Example/]]. His posts [[http://pymotw.com/2/copy/][“copy -- Duplicate Objects”]] and [[http://pymotw.com/2/weakref/][“weakref -- Garbage-Collectable References to Objects”]] cover some of the topics we just discussed.

More information on the CPython generational garbage collector can be found in the [[http://bit.ly/1HGCbmj][gc module documentation]], which starts with the sentence “This module provides an interface to the optional garbage collector.” The “optional” qualifier here may be surprising, but the [[http://bit.ly/1GsZwss][“Data Model” chapter]] also states:

#+BEGIN_QUOTE
  An implementation is allowed to postpone garbage collection or omit it altogether---it is a matter of implementation quality how garbage collection is implemented, as long as no objects are collected that are still reachable.
#+END_QUOTE

Fredrik Lundh---creator of key libraries like ElementTree, Tkinter, and the PIL image library---has a short post about the Python garbage collector titled [[http://bit.ly/1FSDBpM][“How Does Python Manage Memory?”]] He emphasizes that the garbage collector is an implementation feature that behaves differently across Python interpreters. For example, Jython uses the Java garbage collector.

The CPython 3.4 garbage collector improved handling of objects with a =__del__= method, as described in [[http://bit.ly/1HGCde7][PEP 442 --- Safe object finalization]].

Wikipedia has an article about [[http://bit.ly/1HGCduC][string interning]], mentioning the use of this technique in several languages, including Python.

Soapbox

*Equal Treatment to All Objects*

I learned Java before I discovered Python. The ==== operator in Java never felt right for me. It is much more common for programmers to care about equality than identity, but for objects (not primitive types) the Java ==== compares references, and not object values. Even for something as basic as comparing strings, Java forces you to use the =.equals= method. Even then, there is another catch: if you write =a.equals(b)= and =a= is =null=, you get a null pointer exception. The Java designers felt the need to overload =+= for strings, so why not go ahead and overload ==== as well?

Python gets this right. The ==== operator compares object values and =is= compares references. And because Python has operator overloading, ==== works sensibly with all objects in the standard library, including =None=, which is a proper object, unlike Java's =null=.

And of course, you can define =__eq__= in your own classes to decide what ==== means for your instances. If you don't override =__eq__=, the method inherited from =object= compares object IDs, so the fallback is that every instance of a user-defined class is considered different.

These are some of the things that made me switch from Java to Python as soon as I finished reading the Python Tutorial one afternoon in September 1998.

*Mutability*

This chapter would be redundant if all Python objects were immutable. When you are dealing with unchanging objects, it makes no difference whether variables hold the actual objects or references to shared objects. If =a == b= is true, and neither object can change, they might as well be the same. That's why string interning is safe. Object identity becomes important only when objects are mutable.

In “pure” functional programming, all data is immutable: appending to a collection actually creates a new collection. Python, however, is not a functional language, much less a pure one. Instances of user-defined classes are mutable by default in Python---as in most object-oriented languages. When creating your own objects, you have to be extra careful to make them immutable, if that is a requirement. Every attribute of the object must also be immutable, otherwise you end up with something like the =tuple=: immutable as far as object IDs go, but the value of a =tuple= may change if it holds a mutable object.

Mutable objects are also the main reason why programming with threads is so hard to get right: threads mutating objects without proper synchronization produce corrupted data. Excessive synchronization, on the other hand, causes deadlocks.

*Object Destruction and Garbage Collection*

There is no mechanism in Python to directly destroy an object, and this omission is actually a great feature: if you could destroy an object at any time, what would happen to existing strong references pointing to it?

Garbage collection in CPython is done primarily by reference counting, which is easy to implement, but is prone to memory leaking when there are reference cycles, so with version 2.0 (October 2000) a generational garbage collector was implemented, and it is able to dispose of unreachable objects kept alive by reference cycles.

But the reference counting is still there as a baseline, and it causes the immediate disposal of objects with zero references. This means that, in CPython---at least for now---it's safe to write this:

#+BEGIN_EXAMPLE
    open('test.txt', 'wt', encoding='utf-8').write('1, 2, 3')
#+END_EXAMPLE

That code is safe because the reference count of the file object will be zero after the =write= method returns, and Python will immediately close the file before destroying the object representing it in memory. However, the same line is not safe in Jython or IronPython that use the garbage collector of their host runtimes (the Java VM and the .NET CLR), which are more sophisticated but do not rely on reference counting and may take longer to destroy the object and close the file. In all cases, including CPython, the best practice is to explicitly close the file, and the most reliable way of doing it is using the =with= statement, which guarantees that the file will be closed even if exceptions are raised while it is open. Using =with=, the previous snippet becomes:

#+BEGIN_EXAMPLE
    with open('test.txt', 'wt', encoding='utf-8') as fp:
        fp.write('1, 2, 3')
#+END_EXAMPLE

If you are into the subject of garbage collectors, you may want to read Thomas Perl's paper [[http://bit.ly/1Gt0HrJ][“Python Garbage Collector Implementations: CPython, PyPy and GaS”]], from which I learned the bit about the safety of the =open().write()= in CPython.

*Parameter Passing: Call by Sharing*

A popular way of explaining how parameter passing works in Python is the phrase: “Parameters are passed by value, but the values are references.” This not wrong, but causes confusion because the most common parameter passing modes in older languages are /call by value/ (the function gets a copy of the argument) and /call by reference/ (the function gets a pointer to the argument). In Python, the function gets a copy of the arguments, but the arguments are always references. So the value of the referenced objects may be changed, if they are mutable, but their identity cannot. Also, because the function gets a copy of the reference in an argument, rebinding it has no effect outside of the function. I adopted the term /call by sharing/ after reading up on the subject in /Programming Language Pragmatics, Third Edition/ by Michael L. Scott (Morgan Kaufmann), particularly “8.3.1: Parameter Modes.”

*The Full Quote of Alice and the Knights's Song*

I love this passage, but it was too long as a chapter opener. So here is the complete dialog about the Knight's song, its name, and how the song and its name are called:

#+BEGIN_QUOTE
  ‘You are sad,' the Knight said in an anxious tone: ‘let me sing you a song to comfort you.'

  ‘Is it very long?' Alice asked, for she had heard a good deal of poetry that day.

  ‘It's long,' said the Knight, ‘but very, VERY beautiful. Everybody that hears me sing it---either it brings the TEARS into their eyes, or else---'

  ‘Or else what?' said Alice, for the Knight had made a sudden pause.

  ‘Or else it doesn't, you know. The name of the song is called “HADDOCKS' EYES”.'

  ‘Oh, that's the name of the song, is it?' Alice said, trying to feel interested.

  ‘No, you don't understand,' the Knight said, looking a little vexed. ‘That's what the name is CALLED. The name really IS “THE AGED AGED MAN”.'

  ‘Then I ought to have said “That's what the SONG is called”?' Alice corrected herself.

  ‘No, you oughtn't: that's quite another thing! The SONG is called “WAYS AND MEANS”: but that's only what it's CALLED, you know!'

  ‘Well, what IS the song, then?' said Alice, who was by this time completely bewildered.

  ‘I was coming to that,' the Knight said. ‘The song really IS “A-SITTING ON A GATE”: and the tune's my own invention.'

  --- Lewis Carroll /Chapter VIII, “It's My Own Invention,” Through the Looking-Glass/

#+END_QUOTE



--------------


^{[[[#id934635][42]]]} On the other hand, single-type sequences like =str=, =bytes=, and =array.array= are flat: they don't contain references but physically hold their data---characters, bytes, and numbers---in contiguous memory.


^{[[[#id841297][43]]]} If two objects refer to each other, as in [[file:ch08.html#ex_cycle1][Example 8-10]], they may be destroyed if the garbage collector determines that they are otherwise unreachable because their only references are their mutual references.


^{[[[#id568824][44]]]} =cheeseshop.python.org= is also an alias for PyPI---the Python Package Index software repository---which started its life quite empty. At the time of this writing, the Python Cheese Shop has 41,426 packages. Not bad, but still far from the more than 131,000 modules available in CPAN---the Comprehensive Perl Archive Network---the envy of all dynamic language communities.


^{[[[#id784062][45]]]} Parmesan cheese is aged at least a year at the factory, so it is more durable than fresh cheese, but this is not the answer we are looking for.


^{[[[#id732475][46]]]} This is clearly documented. Type =help(tuple)= in the Python console to read: “If the argument is a tuple, the return value is the same object.” I thought I knew everything about tuples before writing this book.


^{[[[#id870346][47]]]} The white lie of having the =copy= method not copying anything can be explained by interface compatibility: it makes =frozenset= more compatible with =set=. Anyway, it makes no difference to the end user whether two identical immutable objects are the same or are copies.


^{[[[#id791035][48]]]} Actually the type of an object may be changed by merely assigning a different class to its =__class__= attribute, but that is pure evil and I regret writing this footnote.


be destroyed if the garbage collector determines that they are otherwise unreachable because their only references are their mutual references.


^{[[[#id568824][44]]]} =cheeseshop.python.org= is also an alias for PyPI---the Python Package Index software repository---which started its life quite empty. At the time of this writing, the Python Cheese Shop has 41,426 packages. Not bad, but still far from the more than 131,000 modules available in CPAN---the Comprehensive Perl Archive Network---the envy of all dynamic language communities.


^{[[[#id784062][45]]]} Parmesan cheese is aged at least a year at the factory, so it is more durable than fresh cheese, but this is not the answer we are looking for.


^{[[[#id732475][46]]]} This is clearly documented. Type =help(tuple)= in the Python console to read: “If the argument is a tuple, the return value is the same object.” I thought I knew everything about tuples before writing this book.


^{[[[#id870346][47]]]} The white lie of having the =copy= method not copying anything can be explained by interface compatibility: it makes =frozenset= more compatible with =set=. Anyway, it makes no difference to the end user whether two identical immutable objects are the same or are copies.


^{[[[#id791035][48]]]} Actually the type of an object may be changed by merely assigning a different class to its =__class__= attribute, but that is pure evil and I regret writing this footnote.


class__= attribute, but that is pure evil and I regret writing this footnote.


