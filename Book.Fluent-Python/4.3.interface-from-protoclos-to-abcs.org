** Chapter 11. Interfaces: From Protocols to ABCs


Virtual subclasses do not inherit from their registered ABCs, and are not checked for conformance to the ABC interface at any time, not even when they are instantiated. It's up to the subclass to actually implement all the methods needed to avoid runtime errors.

The =register= method is usually invoked as a plain function (see [[file:ch11.html#register_usage][Usage of register in Practice]]), but it can also be used as a decorator. In [[file:ch11.html#ex_tombolist][Example 11-14]], we use the decorator syntax and implement =TomboList=, a virtual subclass of =Tombola= depicted in [[file:ch11.html#tombolist_uml][Figure 11-5]].

=TomboList= works as advertised, and the doctests that prove it are described in [[file:ch11.html#how_tombola_tested][How the Tombola Subclasses Were Tested]].



[[file:images/flup_1105.png]]

Figure 11-5. UML class diagram for the TomboList, a real subclass of list and a virtual subclass of Tombola



Example 11-14. tombolist.py: class TomboList is a virtual subclass of Tombola

#+BEGIN_EXAMPLE
    from random import randrange

    from tombola import Tombola

    @Tombola.register  # 
    class TomboList(list):  # 

        def pick(self):
            if self:  # 
                position = randrange(len(self))
                return self.pop(position)  # 
            else:
                raise LookupError('pop from empty TomboList')

        load = list.extend  # 

        def loaded(self):
            return bool(self)  # 

        def inspect(self):
            return tuple(sorted(self))

    # Tombola.register(TomboList)  # 
#+END_EXAMPLE

- [[#CO131-1][[[file:callouts/1.png]]]]  :: =Tombolist= is registered as a virtual subclass of =Tombola=.

- [[#CO131-2][[[file:callouts/2.png]]]]  :: =Tombolist= extends =list=.

- [[#CO131-3][[[file:callouts/3.png]]]]  :: =Tombolist= inherits =__bool__= from =list=, and that returns =True= if the list is not empty.

- [[#CO131-4][[[file:callouts/4.png]]]]  :: Our =pick= calls =self.pop=, inherited from =list=, passing a random item index.

- [[#CO131-5][[[file:callouts/5.png]]]]  :: =Tombolist.load= is the same as =list.extend=.

- [[#CO131-6][[[file:callouts/6.png]]]]  :: =loaded= delegates to =bool=.^{[[[#ftn.id460979][81]]]}

- [[#CO131-7][[[file:callouts/7.png]]]]  :: If you're using Python 3.3 or earlier, you can't use =.register= as a class decorator. You must use standard call syntax.

Note that because of the registration, the functions =issubclass= and =isinstance= act as if =TomboList= is a subclass of =Tombola=:

#+BEGIN_EXAMPLE
    >>> from tombola import Tombola
    >>> from tombolist import TomboList
    >>> issubclass(TomboList, Tombola)
    True
    >>> t = TomboList(range(100))
    >>> isinstance(t, Tombola)
    True
#+END_EXAMPLE

However, inheritance is guided by a special class attribute named =__mro__=---the Method Resolution Order. It basically lists the class and its superclasses in the order Python uses to search for methods.^{[[[#ftn.id1059229][82]]]} If you inspect the =__mro__= of =TomboList=, you'll see that it lists only the “real” superclasses---=list= and =object=:

#+BEGIN_EXAMPLE
    >>> TomboList.__mro__
    (<class 'tombolist.TomboList'>, <class 'list'>, <class 'object'>)
#+END_EXAMPLE

=Tombola= is not in =Tombolist.__mro__=, so =Tombolist= does not inherit any methods from =Tombola=.

As I coded different classes to implement the same interface, I wanted a way to submit them all to the same suite of doctests. The next section shows how I leveraged the API of regular classes and ABCs to do it.

** How the Tombola Subclasses Were Tested


The script I used to test the =Tombola= examples uses two class attributes that allow introspection of a class hierarchy:

-  =__subclasses__()=  :: Method that returns a list of the immediate subclasses of the class. The list does not include virtual subclasses.
-  =_abc_registry=  :: Data attribute---available only in ABCs---that is bound to a =WeakSet= with weak references to registered virtual subclasses of the abstract class.

To test all =Tombola= subclasses, I wrote a script to iterate over a list built from =Tombola.__subclasses__()= and =Tombola._abc_registry=, and bind each class to the name =ConcreteTombola= used in the doctests.

A successful run of the test script looks like this:

#+BEGIN_EXAMPLE
    $ python3 tombola_runner.py
    BingoCage        23 tests,  0 failed - OK
    LotteryBlower    23 tests,  0 failed - OK
    TumblingDrum     23 tests,  0 failed - OK
    TomboList        23 tests,  0 failed - OK
#+END_EXAMPLE

The test script is [[file:ch11.html#ex_tombola_runner][Example 11-15]] and the doctests are in [[file:ch11.html#ex_tombola_tests][Example 11-16]].



Example 11-15. tombola_runner.py: test runner for Tombola subclasses

#+BEGIN_EXAMPLE
    import doctest

    from tombola import Tombola

    # modules to test
    import bingo, lotto, tombolist, drum   

    TEST_FILE = 'tombola_tests.rst'
    TEST_MSG = '{0:16} {1.attempted:2} tests, {1.failed:2} failed - {2}'


    def main(argv):
        verbose = '-v' in argv
        real_subclasses = Tombola.__subclasses__()   
        virtual_subclasses = list(Tombola._abc_registry)   

        for cls in real_subclasses + virtual_subclasses:   
            test(cls, verbose)


    def test(cls, verbose=False):

        res = doctest.testfile(
                TEST_FILE,
                globs={'ConcreteTombola': cls},   
                verbose=verbose,
                optionflags=doctest.REPORT_ONLY_FIRST_FAILURE)
        tag = 'FAIL' if res.failed else 'OK'
        print(TEST_MSG.format(cls.__name__, res, tag))   


    if __name__ == '__main__':
        import sys
        main(sys.argv)
#+END_EXAMPLE

- [[#CO132-1][[[file:callouts/1.png]]]]  :: Import modules containing real or virtual subclasses of =Tombola= for testing.

- [[#CO132-2][[[file:callouts/2.png]]]]  :: =__subclasses__()= lists the direct descendants that are alive in memory. That's why we imported the modules to test, even if there is no further mention of them in the source code: to load the classes into memory.

- [[#CO132-3][[[file:callouts/3.png]]]]  :: Build a =list= from =_abc_registry= (which is a =WeakSet=) so we can concatenate it with the result of =__subclasses__()=.

- [[#CO132-4][[[file:callouts/4.png]]]]  :: Iterate over the subclasses found, passing each to the =test= function.

- [[#CO132-5][[[file:callouts/5.png]]]]  :: The =cls= argument---the class to be tested---is bound to the name =ConcreteTombola= in the global namespace provided to run the doctest.

- [[#CO132-6][[[file:callouts/6.png]]]]  :: The test result is printed with the name of the class, the number of tests attempted, tests failed, and an ='OK'= or ='FAIL'= label.

The doctest file is [[file:ch11.html#ex_tombola_tests][Example 11-16]].



Example 11-16. tombola_tests.rst: doctests for Tombola subclasses

#+BEGIN_EXAMPLE
    ==============
    Tombola tests
    ==============

    Every concrete subclass of Tombola should pass these tests.


    Create and load instance from iterable::

        >>> balls = list(range(3))
        >>> globe = ConcreteTombola(balls)
        >>> globe.loaded()
        True
        >>> globe.inspect()
        (0, 1, 2)


    Pick and collect balls::

        >>> picks = []
        >>> picks.append(globe.pick())
        >>> picks.append(globe.pick())
        >>> picks.append(globe.pick())


    Check state and results::

        >>> globe.loaded()
        False
        >>> sorted(picks) == balls
        True


    Reload::

        >>> globe.load(balls)
        >>> globe.loaded()
        True
        >>> picks = [globe.pick() for i in balls]
        >>> globe.loaded()
        False


    Check that `LookupError` (or a subclass) is the exception
    thrown when the device is empty::

        >>> globe = ConcreteTombola([])
        >>> try:
        ...     globe.pick()
        ... except LookupError as exc:
        ...     print('OK')
        OK


    Load and pick 100 balls to verify that they all come out::

        >>> balls = list(range(100))
        >>> globe = ConcreteTombola(balls)
        >>> picks = []
        >>> while globe.inspect():
        ...     picks.append(globe.pick())
        >>> len(picks) == len(balls)
        True
        >>> set(picks) == set(balls)
        True


    Check that the order has changed and is not simply reversed::

        >>> picks != balls
        True
        >>> picks[::-1] != balls
        True

    Note: the previous 2 tests have a *very* small chance of failing
    even if the implementation is OK. The probability of the 100
    balls coming out, by chance, in the order they were inspect is
    1/100!, or approximately 1.07e-158. It's much easier to win the
    Lotto or to become a billionaire working as a programmer.

    THE END
#+END_EXAMPLE

This concludes our =Tombola= ABC case study. In the next section, we'll address how the =register= ABC function is used in the wild.

** Usage of register in Practice


In [[file:ch11.html#ex_tombolist][Example 11-14]], we used =Tombola.register= as a class decorator. Prior to Python 3.3, =register= could not be used like that---it had to be called as a plain function after the class definition, as suggested by the comment at the end of [[file:ch11.html#ex_tombolist][Example 11-14]].

However, even if =register= can now be used as a decorator, it's more widely deployed as a function to register classes defined elsewhere. For example, in the [[http://bit.ly/1QOA3Lt][source code]] for the =collections.abc= module, the built-in types =tuple=, =str=, =range=, and =memoryview= are registered as virtual subclasses of =Sequence= like this:

#+BEGIN_EXAMPLE
    Sequence.register(tuple)
    Sequence.register(str)
    Sequence.register(range)
    Sequence.register(memoryview)
#+END_EXAMPLE

Several other built-in types are registered to ABCs in [[http://bit.ly/1QOA3Lt][/_collections_abc.py/]]. Those registrations happen only when that module is imported, which is OK because you'll have to import it anyway to get the ABCs: you need access to =MutableMapping= to be able to write =isinstance(my_dict, MutableMapping)=.

We'll wrap up this chapter by explaining a bit of ABC magic that Alex Martelli performed in [[file:ch11.html#waterfowl_essay][Waterfowl and ABCs]].

** Geese Can Behave as Ducks


In his /Waterfowl and ABCs/ essay, Alex shows that a class can be recognized as a virtual subclass of an ABC even without registration. Here is his example again, with an added test using =issubclass=:

#+BEGIN_EXAMPLE
    >>> class Struggle:
    ...     def __len__(self): return 23
    ...
    >>> from collections import abc
    >>> isinstance(Struggle(), abc.Sized)
    True
    >>> issubclass(Struggle, abc.Sized)
    True
#+END_EXAMPLE

Class =Struggle= is considered a subclass of =abc.Sized= by the =issubclass= function (and, consequently, by =isinstance= as well) because =abc.Sized= implements a special class method named =__subclasshook__=. See [[file:ch11.html#sized_source_code][Example 11-17]].



Example 11-17. Sized definition from the source code of [[http://bit.ly/1QOG4aP][Lib/_collections_abc.py]] (Python 3.4)

#+BEGIN_EXAMPLE
    class Sized(metaclass=ABCMeta):

        __slots__ = ()

        @abstractmethod
        def __len__(self):
            return 0

        @classmethod
        def __subclasshook__(cls, C):
            if cls is Sized:
                if any("__len__" in B.__dict__ for B in C.__mro__):  # 
                    return True  # 
            return NotImplemented  # 
#+END_EXAMPLE

- [[#CO133-1][[[file:callouts/1.png]]]]  :: If there is an attribute named =__len__= in the =__dict__= of any class listed in =C.__mro__= (i.e., =C= and its superclasses)...

- [[#CO133-2][[[file:callouts/2.png]]]]  :: ...return =True=, signaling that =C= is a virtual subclass of =Sized=.

- [[#CO133-3][[[file:callouts/3.png]]]]  :: Otherwise return =NotImplemented= to let the subclass check proceed.

If you are interested in the details of the subclass check, see the source code for the =ABCMeta.__subclasscheck__= method in [[https://hg.python.org/cpython/file/3.4/Lib/abc.py#l194][/Lib/abc.py/]]. Beware: it has lots of ifs and two recursive calls.

The =__subclasshook__= adds some duck typing DNA to the whole goose typing proposition. You can have formal interface definitions with ABCs, you can make =isinstance= checks everywhere, and still have a completely unrelated class play along just because it implements a certain method (or because it does whatever it takes to convince a =__subclasshook__= to vouch for it). Of course, this only works for ABCs that do provide a =__subclasshook__=.

Is it a good idea to implement =__subclasshook__= in our own ABCs? Probably not. All the implementations of =__subclasshook__= I've seen in the Python source code are in ABCs like =Sized= that declare just one special method, and they simply check for that special method name. Given their “special” status, you can be pretty sure that any method named =__len__= does what you expect. But even in the realm of special methods and fundamental ABCs, it can be risky to make such assumptions. For example, mappings implement =__len__=, =__getitem__=, and =__iter__= but they are rightly not considered a subtype of =Sequence=, because you can't retrieve items using an integer offset and they make no guarantees about the ordering of items---except of course for =OrderedDict=, which preserves the insertion order, but does support item retrieval by offset either.

For ABCs that you and I may write, a =__subclasshook__= would be even less dependable. I am not ready to believe that any class named =Spam= that implements or inherits =load=, =pick=, =inspect=, and =loaded= is guaranteed to behave as a =Tombola=. It's better to let the programmer affirm it by subclassing =Spam= from =Tombola=, or at least registering: =Tombola.register(Spam)=. Of course, your =__subclasshook__= could also check method signatures and other features, but I just don't think it's worthwhile.

** Chapter Summary


The goal of this chapter was to travel from the highly dynamic nature of informal interfaces---called protocols---visit the static interface declarations of ABCs, and conclude with the dynamic side of ABCs: virtual subclasses and dynamic subclass detection with =__subclasshook__=.

We started the journey by reviewing the traditional understanding of interfaces in the Python community. For most of the history of Python, we've been mindful of interfaces, but they were informal like the protocols from Smalltalk, and the official docs used language such as “foo protocol,” “foo interface,” and “foo-like object” interchangeably. Protocol-style interfaces have nothing to do with inheritance; each class stands alone when implementing a protocol. That's what interfaces look like when you embrace duck typing.

With [[file:ch11.html#ex_minimal_sequence][Example 11-3]], we observed how deeply Python supports the sequence protocol. If a class implements =__getitem__= and nothing else, Python manages to iterate over it, and the =in= operator just works. We then went back to the old =FrenchDeck= example of [[file:ch01.html][Chapter 1]] to support shuffling by dynamically adding a method. This illustrated monkey patching and emphasized the dynamic nature of protocols. Again we saw how a partially implemented protocol can be useful: just adding =__setitem__= from the mutable sequence protocol allowed us to leverage a ready-to-use function from the standard library: =random.shuffle=. Being aware of existing protocols lets us make the most of the rich Python standard library.

Alex Martelli then introduced the term “goose typing”^{[[[#ftn.id1023307][83]]]} to describe a new style of Python programming. With “goose typing,” ABCs are used to make interfaces explicit and classes may claim to implement an interface by subclassing an ABC or by registering with it---without requiring the strong and static link of an inheritance relationship.

The =FrenchDeck2= example made clear the main drawbacks and advantages of explicit ABCs. Inheriting from =abc.MutableSequence= forced us to implement two methods we did not really need: =insert= and =__delitem__=. On the other hand, even a Python newbie can look at =FrenchDeck2= and see that it's a mutable sequence. And, as bonus, we inherited 11 ready-to-use methods from =abc.MutableSequence= (five indirectly from =abc.Sequence=).

After a panoramic view of existing ABCs from =collections.abc= in [[file:ch11.html#collections_uml][Figure 11-3]], we wrote an ABC from scratch. Doug Hellmann, creator of the cool [[http://pymotw.com/][PyMOTW.com]] (Python Module of the Week) explains the motivation:

#+BEGIN_QUOTE
  By defining an abstract base class, a common API can be established for a set of subclasses. This capability is especially useful in situations where someone less familiar with the source for an application is going to provide plug-in extensions...^{[[[#ftn.id477114][84]]]}
#+END_QUOTE

Putting the =Tombola= ABC to work, we created three concrete subclasses: two inheriting from =Tombola=, the other a virtual subclass registered with it, all passing the same suite of tests.

In concluding the chapter, we mentioned how several built-in types are registered to ABCs in the =collections.abc= module so you can ask =isinstance(memoryview, abc.Sequence)= and get =True=, even if =memoryview= does not inherit from =abc.Sequence=. And finally we went over the =__subclasshook__= magic, which lets an ABC recognize any unregistered class as a subclass, as long as it passes a test that can be as simple or as complex as you like---the examples in the standard library merely check for method names.

To sum up, I'd like to restate Alex Martelli's admonition that we should refrain from creating our own ABCs, except when we are building user-extensible frameworks---which most of the time we are not. On a daily basis, our contact with ABCs should be subclassing or registering classes with existing ABCs. Less often than subclassing or registering, we might use ABCs for =isinstance= checks. And even more rarely---if ever---we find occasion to write a new ABC from scratch.

After 15 years of Python, the first abstract class I ever wrote that is not a didactic example was the [[https://github.com/garoa/pingo/blob/master/pingo/board.py][=Board=]] class of the [[http://pingo.io/][Pingo]] project. The drivers that support different single board computers and controllers are subclasses of =Board=, thus sharing the same interface. In reality, although conceived and implemented as an abstract class, the =pingo.Board= class does not subclass =abc.ABC= as I write this.^{[[[#ftn.id907350][85]]]} I intend to make =Board= an explicit ABC eventually---but there are more important things to do in the project.

Here is a fitting quote to end this chapter:

#+BEGIN_QUOTE
  Although ABCs facilitate type checking, it's not something that you should overuse in a program. At its heart, Python is a dynamic language that gives you great flexibility. Trying to enforce type constraints everywhere tends to result in code that is more complicated than it needs to be. You should embrace Python's flexibility.^{[[[#ftn.id552352][86]]]}

  --- David Beazley and Brian Jones /Python Cookbook/

#+END_QUOTE

Or, as technical reviewer Leonardo Rochael wrote: “If you feel tempted to create a custom ABC, please first try to solve your problem through regular duck-typing.”

** Further Reading


Beazley and Jones's /[[http://shop.oreilly.com/product/0636920027072.do][Python Cookbook, 3rd Edition]]/ (O'Reilly) has a section about defining an ABC (Recipe 8.12). The book was written before Python 3.4, so they don't use the now preferred syntax when declaring ABCs by subclassing from =abc.ABC= instead of using the =metaclass= keyword. Apart from this small detail, the recipe covers the major ABC features very well, and ends with the valuable advice quoted at the end of the previous section.

/The Python Standard Library by Example/ by Doug Hellmann (Addison-Wesley), has a chapter about the =abc= module. It's also available on the Web in Doug's excellent [[http://pymotw.com/2/abc/index.html][PyMOTW --- Python Module of the Week]]. Both the book and the site focus on Python 2; therefore, adjustments must be made if you are using Python 3. And for Python 3.4, remember that the only recommended ABC method decorator is =@abstractmethod=---the others were deprecated. The other quote about ABCs in the chapter summary is from Doug's site and book.

When using ABCs, multiple inheritance is not only common but practically inevitable, because each of the fundamental collection ABCs---=Sequence=, =Mapping=, and =Set=---extends multiple ABCs (see [[file:ch11.html#collections_uml][Figure 11-3]]). Therefore, [[file:ch12.html][Chapter 12]] is an important follow-up to this one.

[[https://www.python.org/dev/peps/pep-3119][PEP 3119 --- Introducing Abstract Base Classes]] gives the rationale for ABCs, and [[https://www.python.org/dev/peps/pep-3141][PEP 3141 - A Type Hierarchy for Numbers]] presents the ABCs of the [[https://docs.python.org/3/library/numbers.html][=numbers= module]].

For a discussion of the pros and cons of dynamic typing, see Guido van Rossum's interview to Bill Venners in [[http://www.artima.com/intv/pycontract.html][“Contracts in Python: A Conversation with Guido van Rossum, Part IV”]].

The [[http://docs.zope.org/zope.interface/][=zope.interface=]] package provides a way of declaring interfaces, checking whether objects implement them, registering providers, and querying for providers of a given interface. The package started as a core piece of Zope 3, but it can and has been used outside of Zope. It is the basis of the flexible component architecture of large-scale Python projects like Twisted, Pyramid, and Plone. Lennart Regebro has a great introduction to =zope.interface= in [[http://bit.ly/1QOHa6x][“A Python Component Architecture”]]. Baiju M wrote an entire book about it: [[http://muthukadan.net/docs/zca.html][/A Comprehensive Guide to Zope Component Architecture/]].



Soapbox

*Type Hints*

Probably the biggest news in the Python world in 2014 was that Guido van Rossum gave a green light to the implementation of optional static type checking using function annotations, similar to what the [[http://www.mypy-lang.org/][Mypy]] checker does. This happened in the Python-ideas mailing-list on August 15. The message is [[http://bit.ly/1QOHhyX][Optional static typing --- the crossroads]]. The next month, [[https://www.python.org/dev/peps/pep-0484/][PEP 484 - Type Hints]] was published as a draft, authored by Guido.

The idea is to let programmers optionally use annotations to declare parameter and return types in function definitions. The key word here is /optionally/. You'd only add such annotations if you want the benefits and constraints that come with them, and you could put them in some functions but not in others.

On the surface, this may sound like what Microsoft did with with TypeScript, its JavaScript superset, except that TypeScript goes much further: it adds new language constructs (e.g., modules, classes, explicit interfaces, etc.), allows typed variable declarations, and actually compiles down to plain JavaScript. As of this writing, the goals of optional static typing in Python are much less ambitious.

To understand the reach of this proposal, there is a key point that Guido makes in the historic August 15, 2014, email:

#+BEGIN_QUOTE
  I am going to make one additional assumption: the main use cases will be linting, IDEs, and doc generation. These all have one thing in common: it should be possible to run a program even though it fails to type check. Also, adding types to a program should not hinder its performance (nor will it help :-).
#+END_QUOTE

So, it seems this is not such a radical move as it seems at first. [[https://www.python.org/dev/peps/pep-0482/][PEP 482 - Literature Overview for Type Hints]] is referenced by [[https://www.python.org/dev/peps/pep-0484/][PEP 484 - Type Hints]], and briefly documents type hints in third-party Python tools and in other languages.

Radical or not, type hints are upon us: support for PEP 484 in the form of a =typing= module is likely to land in Python 3.5 already. The way the proposal is worded and implemented makes it clear that no existing code will stop running because of the lack of type hints---or their addition, for that matter.

Finally, PEP 484 clearly states:

#+BEGIN_QUOTE
  It should also be emphasized that Python will remain a dynamically typed language, and the authors have no desire to ever make type hints mandatory, even by convention.
#+END_QUOTE

*Is Python Weakly Typed?*

Discussions about language typing disciplines are sometimes confused due to lack of a uniform terminology. Some writers (like Bill Venners in the interview with Guido mentioned in [[file:ch11.html#interfaces_further_reading][Further Reading]]), say that Python has weak typing, which puts it into the same category of JavaScript and PHP. A better way of talking about typing discipline is to consider two different axes:

-  Strong versus weak typing  :: If the language rarely performs implicit conversion of types, it's considered strongly typed; if it often does it, it's weakly typed. Java, C++, and Python are strongly typed. PHP, JavaScript, and Perl are weakly typed.
-  Static versus dynamic typing  :: If type-checking is performed at compile time, the language is statically typed; if it happens at runtime, it's dynamically typed. Static typing requires type declarations (some modern languages use type inference to avoid some of that). Fortran and Lisp are the two oldest programming languages still alive and they use, respectively, static and dynamic typing.

Strong typing helps catch bugs early.

Here are some examples of why weak typing is bad:^{[[[#ftn.id1010582][87]]]}

#+BEGIN_EXAMPLE
    // this is JavaScript (tested with Node.js v0.10.33)
    '' == '0'   // false
    0 == ''     // true
    0 == '0'    // true
    '' < 0      // false
    '' < '0'    // true
#+END_EXAMPLE

Python does not perform automatic coercion between strings and numbers, so the ==== expressions all result =False=---preserving the transitivity of ====---and the =<= comparisons raise =TypeError= in Python 3.

Static typing makes it easier for tools (compilers, IDEs) to analyze code to detect errors and provide other services (optimization, refactoring, etc.). Dynamic typing increases opportunities for reuse, reducing line count, and allows interfaces to emerge naturally as protocols, instead of being imposed early on.

To summarize, Python uses dynamic and strong typing. [[https://www.python.org/dev/peps/pep-0484/][PEP 484 - Type Hints]] will not change that, but will allow API authors to add optional type annotations so that tools can perform some static type checking.

*Monkey Patching*

Monkey patching has a bad reputation. If abused, it can lead to systems that are hard to understand and maintain. The patch is usually tightly coupled with its target, making it brittle. Another problem is that two libraries that apply monkey-patches may step on each other's toes, with the second library to run destroying patches of the first.

But monkey patching can also be useful, for example, to make a class implement a protocol at runtime. The adapter design pattern solves the same problem by implementing a whole new class.

It's easy to monkey-patch Python code, but there are limitations. Unlike Ruby and JavaScript, Python does not let you monkey-patch the built-in types. I actually consider this an advantage, because you can be certain that a =str= object will always have those same methods. This limitation reduces the chance that external libraries try to apply conflicting patches.

*Interfaces in Java, Go, and Ruby*

Since C++ 2.0 (1989), abstract classes have been used to specify interfaces in that language. The designers of Java opted not to have multiple inheritance of classes, which precluded the use of abstract classes as interface specifications---because often a class needs to implement more than one interface. But they added the =interface= as a language construct, and a class can implement more than one interface---a form of multiple inheritance. Making interface definitions more explicit than ever was a great contribution of Java. With Java 8, an interface can provide method implementations, called [[https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html][Default Methods]]. With this, Java interfaces became closer to abstract classes in C++ and Python.

The Go language has a completely different approach. First of all, there is no inheritance in Go. You can define interfaces, but you don't need (and you actually can't) explicitly say that a certain type implements an interface. The compiler determines that automatically. So what they have in Go could be called “static duck typing,” in the sense that interfaces are checked at compile time but what matters is what types actually implement.

Compared to Python, it's as if, in Go, every ABC implemented the =__subclasshook__= checking function names and signatures, and you never subclassed or registered an ABC. If we wanted Python to look more like Go, we would have to perform type checks on all function arguments. Some of the infrastructure is available (recall [[file:ch05.html#func_annot_sec][Function Annotations]]). Guido has already said he thinks it's OK to use those annotations for type checking---at least in support tools. See [[file:ch05.html#soapbox_1st_class_fn][Soapbox]] in [[file:ch05.html][Chapter 5]] for more about this.

Rubyists are firm believers in duck typing, and Ruby has no formal way to declare an interface or an abstract class, except to do the same we did in Python prior to 2.6: raise =NotImplementedError= in the body of methods to make them abstract by forcing the user to subclass and implement them.

Meanwhile, I read that Yukihiro “Matz” Matsumoto, creator of Ruby, said in a keynote in September 2014 that static typing may be in the future of the language. That was at Ruby Kaigi in Japan, one of the most important Ruby conferences every year. As I write this, I haven't seen a transcript, but Godfrey Chan posted about it on his blog: [[http://brewhouse.io/blog/2014/09/19/ruby-kaigi-2014-day-2][“Ruby Kaigi 2014: Day 2”]]. From Chan's report, it seems Matz focused on function annotations. There is even mention of Python function annotations.

I wonder if function annotations would be really good without ABCs to add structure to the type system without losing flexibility. So maybe formal interfaces are also in the future of Ruby.

I believe Python ABCs, with the =register= function and =__subclasshook__=, brought formal interfaces to the language without throwing away the advantages of dynamic typing.

Perhaps the geese are poised to overtake the ducks.

*Metaphors and Idioms in Interfaces*

A metaphor fosters understanding by making constraints clear. That's the value of the words “stack” and “queue” in describing those fundamental data structures: they make clear how items can be added or removed. On the other hand, Alan Cooper writes in /About Face, 4E/ (Wiley):

#+BEGIN_QUOTE
  Strict adherence to metaphors ties interfaces unnecessarily tightly to the workings of the physical world.
#+END_QUOTE

He's referring to user interfaces, but the admonition applies to APIs as well. But Cooper does grant that when a “truly appropriate” metaphor “falls on our lap,” we can use it (he writes “falls on our lap” because it's so hard to find fitting metaphors that you should not spend time actively looking for them). I believe the bingo machine imagery I used in this chapter is appropriate and I stand by it.

/About Face/ is by far the best book about UI design I've read---and I've read a few. Letting go of metaphors as a design paradigm, and replacing it with “idiomatic interfaces” was the most valuable thing I learned from Cooper's work. As mentioned, Cooper does not deal with APIs, but the more I think about his ideas, the more I see how they apply to Python. The fundamental protocols of the language are what Cooper calls “idioms.” Once we learn what a “sequence” is we can apply that knowledge in different contexts. This is a main theme of /Fluent Python/: highlighting the fundamental idioms of the language, so your code is concise, effective, and readable---for a fluent Pythonista.



--------------


^{[[[#id495252][67]]]} Bjarne Stroustrup, /The Design and Evolution of C++/ (Addison-Wesley, 1994), p. 278.


^{[[[#id578610][68]]]} [[http://bugs.python.org/issue16518][Issue16518: “add /buffer protocol/ to glossary”]] was actually resolved by replacing many mentions of “object that supports the buffer protocol/interface/API” with “bytes-like object”; a follow-up issue is [[http://bugs.python.org/issue22581][“Other mentions of the buffer protocol”]].


^{[[[#id822796][69]]]} You can also, of course, define your own ABCs---but I would discourage all but the most advanced Pythonistas from going that route, just as I would discourage them from defining their own custom metaclasses... and even for said “most advanced Pythonistas,” those of us sporting deep mastery of every fold and crease in the language, these are not tools for frequent use: such “deep metaprogramming,” if ever appropriate, is intended for authors of broad frameworks meant to be independently extended by vast numbers of separate development teams... less than 1% of “most advanced Pythonistas” may ever need that! --- /A.M./


^{[[[#id402701][70]]]} Unfortunately, in Python 3.4, there is no ABC that helps distinguish a =str= from =tuple= or other immutable sequences, so we must test against =str=. In Python 2, the =basestr= type exists to help with tests like these. It's not an ABC, but it's a superclass of both =str= and =unicode=; however, in Python 3, =basestr= is gone. Curiously, there is in Python 3 a =collections.abc.ByteString= type, but it only helps detecting =bytes= and =bytearray=.


^{[[[#id391666][71]]]} This snippet was extracted from [[file:ch21.html#record_factory_ex][Example 21-2]].


^{[[[#id672780][72]]]} Multiple inheritance was /considered harmful/ and excluded from Java, except for interfaces: Java interfaces can extend multiple interfaces, and Java classes can implement multiple interfaces.


^{[[[#id479746][73]]]} For callable detection, there is the =callable()= built-in function---but there is no equivalent =hashable()= function, so =isinstance(my_obj, Hashable)= is the preferred way to test for a hashable object.


^{[[[#id692310][74]]]} Perhaps the client needs to audit the randomizer; or the agency wants to provide a rigged one. You never know...


^{[[[#id439702][75]]]} The Oxford English Dictionary defines tombola as “A kind of lottery resembling lotto.”


^{[[[#id996071][76]]]} «registered» and «virtual subclass» are not standard UML words. We are using them to represent a class relationship that is specific to Python.


^{[[[#id443944][77]]]} Before ABCs existed, abstract methods would use the statement =raise NotImplementedError= to signal that subclasses were responsible for their implementation.


^{[[[#id962479][78]]]} [[http://bit.ly/1QOFpGB][=@abc.abstractmethod=]] entry in the [[https://docs.python.org/dev/library/abc.html][=abc= module documentation]].


^{[[[#id995539][79]]]} I gave this as an example of duck typing after Martelli's [[file:ch11.html#waterfowl_essay][Waterfowl and ABCs]].


^{[[[#id537400][80]]]} [[file:ch08.html#defensive_argument][Defensive Programming with Mutable Parameters]] in [[file:ch08.html][Chapter 8]] was devoted to the aliasing issue we just avoided here.


^{[[[#id460979][81]]]} The same trick I used with =load= doesn't work with =loaded=, because the =list= type does not implement =__bool__=, the method I'd have to bind to =loaded=. On the other hand, the =bool= built-in function doesn't need =__bool__= to work because it can also use =__len__=. See [[https://docs.python.org/3/library/stdtypes.html#truth][“4.1. Truth Value Testing”]] in the “Built-in Types” chapter.


^{[[[#id1059229][82]]]} There is a whole section explaining the =__mro__= class attribute in [[file:ch12.html#mro_section][Multiple Inheritance and Method Resolution Order]]. Right now, this quick explanation will do.


^{[[[#id1023307][83]]]} Alex coined the expression “goose typing” and this is the first time ever it appears in a book!


^{[[[#id477114][84]]]} PyMOTW, =abc= module page, section [[http://bit.ly/1QOGle5][“Why use Abstract Base Classes?”]]


^{[[[#id907350][85]]]} You'll find that in the Python standard library too: classes that are in fact abstract but nobody ever made them explicitly so.


^{[[[#id552352][86]]]} /Python Cookbook, 3rd Edition/ (O'Reilly), “Recipe 8.12. Defining an Interface or Abstract Base Class”, p. 276.


^{[[[#id1010582][87]]]} Adapted from Douglas Crockford's /JavaScript: The Good Parts/ (O'Reilly), Appendix B, p. 109.


the statement =raise NotImplementedError= to signal that subclasses were responsible for their implementation.


^{[[[#id962479][78]]]} [[http://bit.ly/1QOFpGB][=@abc.abstractmethod=]] entry in the [[https://docs.python.org/dev/library/abc.html][=abc= module documentation]].


^{[[[#id995539][79]]]} I gave this as an example of duck typing after Martelli's [[file:ch11.html#waterfowl_essay][Waterfowl and ABCs]].


^{[[[#id537400][80]]]} [[file:ch08.html#defensive_argument][Defensive Programming with Mutable Parameters]] in [[file:ch08.html][Chapter 8]] was devoted to the aliasing issue we just avoided here.


^{[[[#id460979][81]]]} The same trick I used with =load= doesn't work with =loaded=, because the =list= type does not implement =__bool__=, the method I'd have to bind to =loaded=. On the other hand, the =bool= built-in function doesn't need =__bool__= to work because it can also use =__len__=. See [[https://docs.python.org/3/library/stdtypes.html#truth][“4.1. Truth Value Testing”]] in the “Built-in Types” chapter.


^{[[[#id1059229][82]]]} There is a whole section explaining the =__mro__= class attribute in [[file:ch12.html#mro_section][Multiple Inheritance and Method Resolution Order]]. Right now, this quick explanation will do.


^{[[[#id1023307][83]]]} Alex coined the expression “goose typing” and this is the first time ever it appears in a book!


^{[[[#id477114][84]]]} PyMOTW, =abc= module page, section [[http://bit.ly/1QOGle5][“Why use Abstract Base Classes?”]]


^{[[[#id907350][85]]]} You'll find that in the Python standard library too: classes that are in fact abstract but nobody ever made them explicitly so.


^{[[[#id552352][86]]]} /Python Cookbook, 3rd Edition/ (O'Reilly), “Recipe 8.12. Defining an Interface or Abstract Base Class”, p. 276.


^{[[[#id1010582][87]]]} Adapted from Douglas Crockford's /JavaScript: The Good Parts/ (O'Reilly), Appendix B, p. 109.


 Base Class”, p. 276.


^{[[[#id1010582][87]]]} Adapted from Douglas Crockford's /JavaScript: The Good Parts/ (O'Reilly), Appendix B, p. 109.


d raise `LookupError` when the instance is empty.
            """

        def loaded(self):   
            """Return `True` if there's at least 1 item, `False` otherwise."""
            return bool(self.inspect())   


        def inspect(self):
            """Return a sorted tuple with the items currently inside."""
            items = []
            while True:   
                try:
                    items.append(self.pick())
                except LookupError:
                    break
            self.load(items)   
            return tuple(sorted(items))
#+END_EXAMPLE

- [[#CO126-1][[[file:callouts/1.png]]]]  :: To define an ABC, subclass =abc.ABC=.

- [[#CO126-2][[[file:callouts/2.png]]]]  :: An abstract method is marked with the =@abstractmethod= decorator, and often its body is empty except for a docstring.^{[[[#ftn.id443944][77]]]}

- [[#CO126-3][[[file:callouts/3.png]]]]  :: The docstring instructs implementers to raise =LookupError= if there are no items to pick.

- [[#CO126-4][[[file:callouts/4.png]]]]  :: An ABC may include concrete methods.

- [[#CO126-5][[[file:callouts/5.png]]]]  :: Concrete methods in an ABC must rely only on the interface defined by the ABC (i.e., other concrete or abstract methods or properties of the ABC).

- [[#CO126-6][[[file:callouts/6.png]]]]  :: We can't know how concrete subclasses will store the items, but we can build the =inspect= result by emptying the =Tombola= with successive calls to =.pick()=...

- [[#CO126-7][[[file:callouts/7.png]]]]  :: ...then use =.load(…)= to put everything back.

*** Tip
    :PROPERTIES:
    :CUSTOM_ID: tip-4
    :CLASS: title
    :END:

An abstract method can actually have an implementation. Even if it does, subclasses will still be forced to override it, but they will be able to invoke the abstract method with =super()=, adding functionality to it instead of implementing from scratch. See the [[https://docs.python.org/3/library/abc.html][=abc= module documentation]] for details on =@abstractmethod= usage.

The =.inspect()= method in [[file:ch11.html#ex_tombola_abc][Example 11-9]] is perhaps a silly example, but it shows that, given =.pick()= and =.load(…)= we can inspect what's inside the =Tombola= by picking all items and loading them back. The point of this example is to highlight that it's OK to provide concrete methods in ABCs, as long as they only depend on other methods in the interface. Being aware of their internal data structures, concrete subclasses of =Tombola= may always override =.inspect()= with a smarter implementation, but they don't have to.

The =.loaded()= method in [[file:ch11.html#ex_tombola_abc][Example 11-9]] may not be as silly, but it's expensive: it calls =.inspect()= to build the sorted =tuple= just to apply =bool()= on it. This works, but a concrete subclass can do much better, as we'll see.

Note that our roundabout implementation of =.inspect()= requires that we catch a =LookupError= thrown by =self.pick()=. The fact that =self.pick()= may raise =LookupError= is also part of its interface, but there is no way to declare this in Python, except in the documentation (see the docstring for the abstract =pick= method in [[file:ch11.html#ex_tombola_abc][Example 11-9]].)

I chose the =LookupError= exception because of its place in the Python hierarchy of exceptions in relation to =IndexError= and =KeyError=, the most likely exceptions to be raised by the data structures used to implement a concrete =Tombola=. Therefore, implementations can raise =LookupError=, =IndexError=, or =KeyError= to comply. See [[file:ch11.html#exc_tree_part][Example 11-10]] (for a complete tree, see “5.4. Exception hierarchy” of /The Python Standard Library/).



Example 11-10. Part of the Exception class hierarchy

#+BEGIN_SRC screen
    BaseException
     ├── SystemExit
     ├── KeyboardInterrupt
     ├── GeneratorExit
     └── Exception
          ├── StopIteration
          ├── ArithmeticError
          │    ├── FloatingPointError
          │    ├── OverflowError
          │    └── ZeroDivisionError
          ├── AssertionError
          ├── AttributeError
          ├── BufferError
          ├── EOFError
          ├── ImportError
          ├── LookupError  
          │    ├── IndexError  
          │    └── KeyError  
          ├── MemoryError
          ... etc.
#+END_SRC

- [[#CO127-1][[[file:callouts/1.png]]]]  :: =LookupError= is the exception we handle in =Tombola.inspect=.

- [[#CO127-2][[[file:callouts/2.png]]]]  :: =IndexError= is the =LookupError= subclass raised when we try to get an item from a sequence with an index beyond the last position.

- [[#CO127-3][[[file:callouts/3.png]]]]  :: =KeyError= is raised when we use a nonexistent key to get an item from a mapping.

We now have our very own =Tombola= ABC. To witness the interface checking performed by an ABC, let's try to fool =Tombola= with a defective implementation in [[file:ch11.html#fake_tombola_ex][Example 11-11]].



Example 11-11. A fake Tombola doesn't go undetected

#+BEGIN_EXAMPLE
    >>> from tombola import Tombola
    >>> class Fake(Tombola):  # 
    ...     def pick(self):
    ...         return 13
    ...
    >>> Fake  # 
    <class '__main__.Fake'>
    <class 'abc.ABC'>, <class 'object'>)
    >>> f = Fake()  # 
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: Can't instantiate abstract class Fake with abstract methods load
#+END_EXAMPLE

- [[#CO128-1][[[file:callouts/1.png]]]]  :: Declare =Fake= as a subclass of =Tombola=.

- [[#CO128-2][[[file:callouts/2.png]]]]  :: The class was created, no errors so far.

- [[#CO128-3][[[file:callouts/3.png]]]]  :: =TypeError= is raised when we try to instantiate =Fake=. The message is very clear: =Fake= is considered abstract because it failed to implement =load=, one of the abstract methods declared in the =Tombola= ABC.

So we have our first ABC defined, and we put it to work validating a class. We'll soon subclass the =Tombola= ABC, but first we must cover some ABC coding rules.

*** ABC Syntax Details
    :PROPERTIES:
    :CUSTOM_ID: abc_syntax_section
    :CLASS: title
    :END:

The best way to declare an ABC is to subclass =abc.ABC= or any other ABC.

However, the =abc.ABC= class is new in Python 3.4, so if you are using an earlier version of Python---and it does not make sense to subclass another existing ABC---then you must use the =metaclass== keyword in the =class= statement, pointing to =abc.ABCMeta= (not =abc.ABC=). In [[file:ch11.html#ex_tombola_abc][Example 11-9]], we would write:

#+BEGIN_EXAMPLE
    class Tombola(metaclass=abc.ABCMeta):
        # ...
#+END_EXAMPLE

The =metaclass== keyword argument was introduced in Python 3. In Python 2, you must use the =__metaclass__= class attribute:

#+BEGIN_EXAMPLE
    class Tombola(object):  # this is Python 2!!!
        __metaclass__ = abc.ABCMeta
        # ...
#+END_EXAMPLE

We'll explain metaclasses in [[file:ch21.html][Chapter 21]]. For now, let's accept that a metaclass is a special kind of class, and agree that an ABC is a special kind of class; for example, “regular” classes don't check subclasses, so this is a special behavior of ABCs.

Besides the =@abstractmethod=, the =abc= module defines the =@abstractclassmethod=, =@abstractstaticmethod=, and =@abstractproperty= decorators. However, these last three are deprecated since Python 3.3, when it became possible to stack decorators on top of =@abstractmethod=, making the others redundant. For example, the preferred way to declare an abstract class method is:

#+BEGIN_EXAMPLE
    class MyABC(abc.ABC):
        @classmethod
        @abc.abstractmethod
        def an_abstract_classmethod(cls, ...):
            pass
#+END_EXAMPLE

*** Warning
    :PROPERTIES:
    :CUSTOM_ID: warning-2
    :CLASS: title
    :END:

The order of stacked function decorators usually matters, and in the case of =@abstractmethod=, the documentation is explicit:

#+BEGIN_QUOTE
  When abstractmethod() is applied in combination with other method descriptors, it should be applied as the innermost decorator, ...^{[[[#ftn.id962479][78]]]}
#+END_QUOTE

In other words, no other decorator may appear between =@abstractmethod= and the =def= statement.

Now that we got these ABC syntax issues covered, let's put =Tombola= to use by implementing some full-fledged concrete descendants of it.

*** Subclassing the Tombola ABC
    :PROPERTIES:
    :CUSTOM_ID: _subclassing_the_tombola_abc
    :CLASS: title
    :END:

Given the =Tombola= ABC, we'll now develop two concrete subclasses that satisfy its interface. These classes were pictured in [[file:ch11.html#tombola_uml][Figure 11-4]], along with the virtual subclass to be discussed in the next section.

The =BingoCage= class in [[file:ch11.html#ex_tombola_bingo][Example 11-12]] is a variation of [[file:ch05.html#ex_bingo_callable][Example 5-8]] using a better randomizer. This =BingoCage= implements the required abstract methods =load= and =pick=, inherits =loaded= from =Tombola=, overrides =inspect=, and adds =__call__=.



Example 11-12. bingo.py: BingoCage is a concrete subclass of Tombola

#+BEGIN_EXAMPLE
    import random

    from tombola import Tombola


    class BingoCage(Tombola):   

        def __init__(self, items):
            self._randomizer = random.SystemRandom()   
            self._items = []
            self.load(items)   

        def load(self, items):
            self._items.extend(items)
            self._randomizer.shuffle(self._items)   

        def pick(self):   
            try:
                return self._items.pop()
            except IndexError:
                raise LookupError('pick from empty BingoCage')

        def __call__(self):   
            self.pick()
#+END_EXAMPLE

- [[#CO129-1][[[file:callouts/1.png]]]]  :: This =BingoCage= class explicitly extends =Tombola=.

- [[#CO129-2][[[file:callouts/2.png]]]]  :: Pretend we'll use this for online gaming. =random.SystemRandom= implements the =random= API on top of the =os.urandom(…)= function, which provides random bytes “suitable for cryptographic use” according to the [[http://docs.python.org/3/library/os.html#os.urandom][=os= module docs]].

- [[#CO129-3][[[file:callouts/3.png]]]]  :: Delegate initial loading to the =.load(…)= method.

- [[#CO129-4][[[file:callouts/4.png]]]]  :: Instead of the plain =random.shuffle()= function, we use the =.shuffle()= method of our =SystemRandom= instance.

- [[#CO129-5][[[file:callouts/5.png]]]]  :: =pick= is implemented as in [[file:ch05.html#ex_bingo_callable][Example 5-8]].

- [[#CO129-6][[[file:callouts/6.png]]]]  :: =__call__= is also from [[file:ch05.html#ex_bingo_callable][Example 5-8]]. It's not needed to satisfy the =Tombola= interface, but there's no harm in adding extra methods.

=BingoCage= inherits the expensive =loaded= and the silly =inspect= methods from =Tombola=. Both could be overridden with much faster one-liners, as in [[file:ch11.html#ex_lotto][Example 11-13]]. The point is: we can be lazy and just inherit the suboptimal concrete methods from an ABC. The methods inherited from =Tombola= are not as fast as they could be for =BingoCage=, but they do provide correct results for any =Tombola= subclass that correctly implements =pick= and =load=.

[[file:ch11.html#ex_lotto][Example 11-13]] shows a very different but equally valid implementation of the =Tombola= interface. Instead of shuffling the “balls” and popping the last, =LotteryBlower= pops from a random position.



Example 11-13. lotto.py: LotteryBlower is a concrete subclass that overrides the inspect and loaded methods from Tombola

#+BEGIN_EXAMPLE
    import random

    from tombola import Tombola


    class LotteryBlower(Tombola):

        def __init__(self, iterable):
            self._balls = list(iterable)   

        def load(self, iterable):
            self._balls.extend(iterable)

        def pick(self):
            try:
                position = random.randrange(len(self._balls))   
            except ValueError:
                raise LookupError('pick from empty BingoCage')
            return self._balls.pop(position)   

        def loaded(self):   
            return bool(self._balls)

        def inspect(self):   
            return tuple(sorted(self._balls))
#+END_EXAMPLE

- [[#CO130-1][[[file:callouts/1.png]]]]  :: The initializer accepts any iterable: the argument is used to build a list.

- [[#CO130-2][[[file:callouts/2.png]]]]  :: The =random.randrange(…)= function raises =ValueError= if the range is empty, so we catch that and throw =LookupError= instead, to be compatible with =Tombola=.

- [[#CO130-3][[[file:callouts/3.png]]]]  :: Otherwise the randomly selected item is popped from =self._balls=.

- [[#CO130-4][[[file:callouts/4.png]]]]  :: Override =loaded= to avoid calling =inspect= (as =Tombola.loaded= does in [[file:ch11.html#ex_tombola_abc][Example 11-9]]). We can make it faster by working with =self._balls= directly---no need to build a whole sorted =tuple=.

- [[#CO130-5][[[file:callouts/5.png]]]]  :: Override =inspect= with one-liner.

[[file:ch11.html#ex_lotto][Example 11-13]] illustrates an idiom worth mentioning: in =__init__=, =self._balls= stores =list(iterable)= and not just a reference to =iterable= (i.e., we did not merely assign =iterable= to =self._balls=). As mentioned before,^{[[[#ftn.id995539][79]]]} this makes our =LotteryBlower= flexible because the =iterable= argument may be any iterable type. At the same time, we make sure to store its items in a =list= so we can =pop= items. And even if we always get lists as the =iterable= argument, =list(iterable)= produces a copy of the argument, which is a good practice considering we will be removing items from it and the client may not be expecting the =list= of items she provided to be changed.^{[[[#ftn.id537400][80]]]}

We now come to the crucial dynamic feature of goose typing: declaring virtual subclasses with the =register= method.

*** A Virtual Subclass of Tombola
    :PROPERTIES:
    :CUSTOM_ID: _a_virtual_subclass_of_tombola
    :CLASS: title
    :END:

An essential characteristic of goose typing---and the reason why it deserves a waterfowl name---is the ability to register a class as a /virtual subclass/ of an ABC, even if it does not inherit from it. When doing so, we promise that the class faithfully implements the interface defined in the ABC---and Python will believe us without checking. If we lie, we'll be caught by the usual runtime exceptions.

This is done by calling a =register= method on the ABC. The registered class then becomes a virtual subclass of the ABC, and will be recognized as such by functions like =issubclass= and =isinstance=, but it will not inherit any methods or attributes from the ABC.

*** Warning
    :PROPERTIES:
    :CUSTOM_ID: warning-3
    :CLASS: title
    :END:

Virtual subclasses do not inherit from their registered ABCs, and are not checked for conformance to the ABC interface at any time, not even when they are instantiated. It's up to the subclass to actually implement all the methods needed to avoid runtime errors.

The =register= method is usually invoked as a plain function (see [[file:ch11.html#register_usage][Usage of register in Practice]]), but it can also be used as a decorator. In [[file:ch11.html#ex_tombolist][Example 11-14]], we use the decorator syntax and implement =TomboList=, a virtual subclass of =Tombola= depicted in [[file:ch11.html#tombolist_uml][Figure 11-5]].

=TomboList= works as advertised, and the doctests that prove it are described in [[file:ch11.html#how_tombola_tested][How the Tombola Subclasses Were Tested]].



[[file:images/flup_1105.png]]

Figure 11-5. UML class diagram for the TomboList, a real subclass of list and a virtual subclass of Tombola



Example 11-14. tombolist.py: class TomboList is a virtual subclass of Tombola

#+BEGIN_EXAMPLE
    from random import randrange

    from tombola import Tombola

    @Tombola.register  # 
    class TomboList(list):  # 

        def pick(self):
            if self:  # 
                position = randrange(len(self))
                return self.pop(position)  # 
            else:
                raise LookupError('pop from empty TomboList')

        load = list.extend  # 

        def loaded(self):
            return bool(self)  # 

        def inspect(self):
            return tuple(sorted(self))

    # Tombola.register(TomboList)  # 
#+END_EXAMPLE

- [[#CO131-1][[[file:callouts/1.png]]]]  :: =Tombolist= is registered as a virtual subclass of =Tombola=.

- [[#CO131-2][[[file:callouts/2.png]]]]  :: =Tombolist= extends =list=.

- [[#CO131-3][[[file:callouts/3.png]]]]  :: =Tombolist= inherits =__bool__= from =list=, and that returns =True= if the list is not empty.

- [[#CO131-4][[[file:callouts/4.png]]]]  :: Our =pick= calls =self.pop=, inherited from =list=, passing a random item index.

- [[#CO131-5][[[file:callouts/5.png]]]]  :: =Tombolist.load= is the same as =list.extend=.

- [[#CO131-6][[[file:callouts/6.png]]]]  :: =loaded= delegates to =bool=.^{[[[#ftn.id460979][81]]]}

- [[#CO131-7][[[file:callouts/7.png]]]]  :: If you're using Python 3.3 or earlier, you can't use =.register= as a class decorator. You must use standard call syntax.

Note that because of the registration, the functions =issubclass= and =isinstance= act as if =TomboList= is a subclass of =Tombola=:

#+BEGIN_EXAMPLE
    >>> from tombola import Tombola
    >>> from tombolist import TomboList
    >>> issubclass(TomboList, Tombola)
    True
    >>> t = TomboList(range(100))
    >>> isinstance(t, Tombola)
    True
#+END_EXAMPLE

However, inheritance is guided by a special class attribute named =__mro__=---the Method Resolution Order. It basically lists the class and its superclasses in the order Python uses to search for methods.^{[[[#ftn.id1059229][82]]]} If you inspect the =__mro__= of =TomboList=, you'll see that it lists only the “real” superclasses---=list= and =object=:

#+BEGIN_EXAMPLE
    >>> TomboList.__mro__
    (<class 'tombolist.TomboList'>, <class 'list'>, <class 'object'>)
#+END_EXAMPLE

=Tombola= is not in =Tombolist.__mro__=, so =Tombolist= does not inherit any methods from =Tombola=.

As I coded different classes to implement the same interface, I wanted a way to submit them all to the same suite of doctests. The next section shows how I leveraged the API of regular classes and ABCs to do it.

** How the Tombola Subclasses Were Tested


The script I used to test the =Tombola= examples uses two class attributes that allow introspection of a class hierarchy:

-  =__subclasses__()=  :: Method that returns a list of the immediate subclasses of the class. The list does not include virtual subclasses.
-  =_abc_registry=  :: Data attribute---available only in ABCs---that is bound to a =WeakSet= with weak references to registered virtual subclasses of the abstract class.

To test all =Tombola= subclasses, I wrote a script to iterate over a list built from =Tombola.__subclasses__()= and =Tombola._abc_registry=, and bind each class to the name =ConcreteTombola= used in the doctests.

A successful run of the test script looks like this:

#+BEGIN_EXAMPLE
    $ python3 tombola_runner.py
    BingoCage        23 tests,  0 failed - OK
    LotteryBlower    23 tests,  0 failed - OK
    TumblingDrum     23 tests,  0 failed - OK
    TomboList        23 tests,  0 failed - OK
#+END_EXAMPLE

The test script is [[file:ch11.html#ex_tombola_runner][Example 11-15]] and the doctests are in [[file:ch11.html#ex_tombola_tests][Example 11-16]].



Example 11-15. tombola_runner.py: test runner for Tombola subclasses

#+BEGIN_EXAMPLE
    import doctest

    from tombola import Tombola

    # modules to test
    import bingo, lotto, tombolist, drum   

    TEST_FILE = 'tombola_tests.rst'
    TEST_MSG = '{0:16} {1.attempted:2} tests, {1.failed:2} failed - {2}'


    def main(argv):
        verbose = '-v' in argv
        real_subclasses = Tombola.__subclasses__()   
        virtual_subclasses = list(Tombola._abc_registry)   

        for cls in real_subclasses + virtual_subclasses:   
            test(cls, verbose)


    def test(cls, verbose=False):

        res = doctest.testfile(
                TEST_FILE,
                globs={'ConcreteTombola': cls},   
                verbose=verbose,
                optionflags=doctest.REPORT_ONLY_FIRST_FAILURE)
        tag = 'FAIL' if res.failed else 'OK'
        print(TEST_MSG.format(cls.__name__, res, tag))   


    if __name__ == '__main__':
        import sys
        main(sys.argv)
#+END_EXAMPLE

- [[#CO132-1][[[file:callouts/1.png]]]]  :: Import modules containing real or virtual subclasses of =Tombola= for testing.

- [[#CO132-2][[[file:callouts/2.png]]]]  :: =__subclasses__()= lists the direct descendants that are alive in memory. That's why we imported the modules to test, even if there is no further mention of them in the source code: to load the classes into memory.

- [[#CO132-3][[[file:callouts/3.png]]]]  :: Build a =list= from =_abc_registry= (which is a =WeakSet=) so we can concatenate it with the result of =__subclasses__()=.

- [[#CO132-4][[[file:callouts/4.png]]]]  :: Iterate over the subclasses found, passing each to the =test= function.

- [[#CO132-5][[[file:callouts/5.png]]]]  :: The =cls= argument---the class to be tested---is bound to the name =ConcreteTombola= in the global namespace provided to run the doctest.

- [[#CO132-6][[[file:callouts/6.png]]]]  :: The test result is printed with the name of the class, the number of tests attempted, tests failed, and an ='OK'= or ='FAIL'= label.

The doctest file is [[file:ch11.html#ex_tombola_tests][Example 11-16]].



Example 11-16. tombola_tests.rst: doctests for Tombola subclasses

#+BEGIN_EXAMPLE
    ==============
    Tombola tests
    ==============

    Every concrete subclass of Tombola should pass these tests.


    Create and load instance from iterable::

        >>> balls = list(range(3))
        >>> globe = ConcreteTombola(balls)
        >>> globe.loaded()
        True
        >>> globe.inspect()
        (0, 1, 2)


    Pick and collect balls::

        >>> picks = []
        >>> picks.append(globe.pick())
        >>> picks.append(globe.pick())
        >>> picks.append(globe.pick())


    Check state and results::

        >>> globe.loaded()
        False
        >>> sorted(picks) == balls
        True


    Reload::

        >>> globe.load(balls)
        >>> globe.loaded()
        True
        >>> picks = [globe.pick() for i in balls]
        >>> globe.loaded()
        False


    Check that `LookupError` (or a subclass) is the exception
    thrown when the device is empty::

        >>> globe = ConcreteTombola([])
        >>> try:
        ...     globe.pick()
        ... except LookupError as exc:
        ...     print('OK')
        OK


    Load and pick 100 balls to verify that they all come out::

        >>> balls = list(range(100))
        >>> globe = ConcreteTombola(balls)
        >>> picks = []
        >>> while globe.inspect():
        ...     picks.append(globe.pick())
        >>> len(picks) == len(balls)
        True
        >>> set(picks) == set(balls)
        True


    Check that the order has changed and is not simply reversed::

        >>> picks != balls
        True
        >>> picks[::-1] != balls
        True

    Note: the previous 2 tests have a *very* small chance of failing
    even if the implementation is OK. The probability of the 100
    balls coming out, by chance, in the order they were inspect is
    1/100!, or approximately 1.07e-158. It's much easier to win the
    Lotto or to become a billionaire working as a programmer.

    THE END
#+END_EXAMPLE

This concludes our =Tombola= ABC case study. In the next section, we'll address how the =register= ABC function is used in the wild.

** Usage of register in Practice


In [[file:ch11.html#ex_tombolist][Example 11-14]], we used =Tombola.register= as a class decorator. Prior to Python 3.3, =register= could not be used like that---it had to be called as a plain function after the class definition, as suggested by the comment at the end of [[file:ch11.html#ex_tombolist][Example 11-14]].

However, even if =register= can now be used as a decorator, it's more widely deployed as a function to register classes defined elsewhere. For example, in the [[http://bit.ly/1QOA3Lt][source code]] for the =collections.abc= module, the built-in types =tuple=, =str=, =range=, and =memoryview= are registered as virtual subclasses of =Sequence= like this:

#+BEGIN_EXAMPLE
    Sequence.register(tuple)
    Sequence.register(str)
    Sequence.register(range)
    Sequence.register(memoryview)
#+END_EXAMPLE

Several other built-in types are registered to ABCs in [[http://bit.ly/1QOA3Lt][/_collections_abc.py/]]. Those registrations happen only when that module is imported, which is OK because you'll have to import it anyway to get the ABCs: you need access to =MutableMapping= to be able to write =isinstance(my_dict, MutableMapping)=.

We'll wrap up this chapter by explaining a bit of ABC magic that Alex Martelli performed in [[file:ch11.html#waterfowl_essay][Waterfowl and ABCs]].

** Geese Can Behave as Ducks


In his /Waterfowl and ABCs/ essay, Alex shows that a class can be recognized as a virtual subclass of an ABC even without registration. Here is his example again, with an added test using =issubclass=:

#+BEGIN_EXAMPLE
    >>> class Struggle:
    ...     def __len__(self): return 23
    ...
    >>> from collections import abc
    >>> isinstance(Struggle(), abc.Sized)
    True
    >>> issubclass(Struggle, abc.Sized)
    True
#+END_EXAMPLE

Class =Struggle= is considered a subclass of =abc.Sized= by the =issubclass= function (and, consequently, by =isinstance= as well) because =abc.Sized= implements a special class method named =__subclasshook__=. See [[file:ch11.html#sized_source_code][Example 11-17]].



Example 11-17. Sized definition from the source code of [[http://bit.ly/1QOG4aP][Lib/_collections_abc.py]] (Python 3.4)

#+BEGIN_EXAMPLE
    class Sized(metaclass=ABCMeta):

        __slots__ = ()

        @abstractmethod
        def __len__(self):
            return 0

        @classmethod
        def __subclasshook__(cls, C):
            if cls is Sized:
                if any("__len__" in B.__dict__ for B in C.__mro__):  # 
                    return True  # 
            return NotImplemented  # 
#+END_EXAMPLE

- [[#CO133-1][[[file:callouts/1.png]]]]  :: If there is an attribute named =__len__= in the =__dict__= of any class listed in =C.__mro__= (i.e., =C= and its superclasses)...

- [[#CO133-2][[[file:callouts/2.png]]]]  :: ...return =True=, signaling that =C= is a virtual subclass of =Sized=.

- [[#CO133-3][[[file:callouts/3.png]]]]  :: Otherwise return =NotImplemented= to let the subclass check proceed.

If you are interested in the details of the subclass check, see the source code for the =ABCMeta.__subclasscheck__= method in [[https://hg.python.org/cpython/file/3.4/Lib/abc.py#l194][/Lib/abc.py/]]. Beware: it has lots of ifs and two recursive calls.

The =__subclasshook__= adds some duck typing DNA to the whole goose typing proposition. You can have formal interface definitions with ABCs, you can make =isinstance= checks everywhere, and still have a completely unrelated class play along just because it implements a certain method (or because it does whatever it takes to convince a =__subclasshook__= to vouch for it). Of course, this only works for ABCs that do provide a =__subclasshook__=.

Is it a good idea to implement =__subclasshook__= in our own ABCs? Probably not. All the implementations of =__subclasshook__= I've seen in the Python source code are in ABCs like =Sized= that declare just one special method, and they simply check for that special method name. Given their “special” status, you can be pretty sure that any method named =__len__= does what you expect. But even in the realm of special methods and fundamental ABCs, it can be risky to make such assumptions. For example, mappings implement =__len__=, =__getitem__=, and =__iter__= but they are rightly not considered a subtype of =Sequence=, because you can't retrieve items using an integer offset and they make no guarantees about the ordering of items---except of course for =OrderedDict=, which preserves the insertion order, but does support item retrieval by offset either.

For ABCs that you and I may write, a =__subclasshook__= would be even less dependable. I am not ready to believe that any class named =Spam= that implements or inherits =load=, =pick=, =inspect=, and =loaded= is guaranteed to behave as a =Tombola=. It's better to let the programmer affirm it by subclassing =Spam= from =Tombola=, or at least registering: =Tombola.register(Spam)=. Of course, your =__subclasshook__= could also check method signatures and other features, but I just don't think it's worthwhile.

** Chapter Summary


The goal of this chapter was to travel from the highly dynamic nature of informal interfaces---called protocols---visit the static interface declarations of ABCs, and conclude with the dynamic side of ABCs: virtual subclasses and dynamic subclass detection with =__subclasshook__=.

We started the journey by reviewing the traditional understanding of interfaces in the Python community. For most of the history of Python, we've been mindful of interfaces, but they were informal like the protocols from Smalltalk, and the official docs used language such as “foo protocol,” “foo interface,” and “foo-like object” interchangeably. Protocol-style interfaces have nothing to do with inheritance; each class stands alone when implementing a protocol. That's what interfaces look like when you embrace duck typing.

With [[file:ch11.html#ex_minimal_sequence][Example 11-3]], we observed how deeply Python supports the sequence protocol. If a class implements =__getitem__= and nothing else, Python manages to iterate over it, and the =in= operator just works. We then went back to the old =FrenchDeck= example of [[file:ch01.html][Chapter 1]] to support shuffling by dynamically adding a method. This illustrated monkey patching and emphasized the dynamic nature of protocols. Again we saw how a partially implemented protocol can be useful: just adding =__setitem__= from the mutable sequence protocol allowed us to leverage a ready-to-use function from the standard library: =random.shuffle=. Being aware of existing protocols lets us make the most of the rich Python standard library.

Alex Martelli then introduced the term “goose typing”^{[[[#ftn.id1023307][83]]]} to describe a new style of Python programming. With “goose typing,” ABCs are used to make interfaces explicit and classes may claim to implement an interface by subclassing an ABC or by registering with it---without requiring the strong and static link of an inheritance relationship.

The =FrenchDeck2= example made clear the main drawbacks and advantages of explicit ABCs. Inheriting from =abc.MutableSequence= forced us to implement two methods we did not really need: =insert= and =__delitem__=. On the other hand, even a Python newbie can look at =FrenchDeck2= and see that it's a mutable sequence. And, as bonus, we inherited 11 ready-to-use methods from =abc.MutableSequence= (five indirectly from =abc.Sequence=).

After a panoramic view of existing ABCs from =collections.abc= in [[file:ch11.html#collections_uml][Figure 11-3]], we wrote an ABC from scratch. Doug Hellmann, creator of the cool [[http://pymotw.com/][PyMOTW.com]] (Python Module of the Week) explains the motivation:

#+BEGIN_QUOTE
  By defining an abstract base class, a common API can be established for a set of subclasses. This capability is especially useful in situations where someone less familiar with the source for an application is going to provide plug-in extensions...^{[[[#ftn.id477114][84]]]}
#+END_QUOTE

Putting the =Tombola= ABC to work, we created three concrete subclasses: two inheriting from =Tombola=, the other a virtual subclass registered with it, all passing the same suite of tests.

In concluding the chapter, we mentioned how several built-in types are registered to ABCs in the =collections.abc= module so you can ask =isinstance(memoryview, abc.Sequence)= and get =True=, even if =memoryview= does not inherit from =abc.Sequence=. And finally we went over the =__subclasshook__= magic, which lets an ABC recognize any unregistered class as a subclass, as long as it passes a test that can be as simple or as complex as you like---the examples in the standard library merely check for method names.

To sum up, I'd like to restate Alex Martelli's admonition that we should refrain from creating our own ABCs, except when we are building user-extensible frameworks---which most of the time we are not. On a daily basis, our contact with ABCs should be subclassing or registering classes with existing ABCs. Less often than subclassing or registering, we might use ABCs for =isinstance= checks. And even more rarely---if ever---we find occasion to write a new ABC from scratch.

After 15 years of Python, the first abstract class I ever wrote that is not a didactic example was the [[https://github.com/garoa/pingo/blob/master/pingo/board.py][=Board=]] class of the [[http://pingo.io/][Pingo]] project. The drivers that support different single board computers and controllers are subclasses of =Board=, thus sharing the same interface. In reality, although conceived and implemented as an abstract class, the =pingo.Board= class does not subclass =abc.ABC= as I write this.^{[[[#ftn.id907350][85]]]} I intend to make =Board= an explicit ABC eventually---but there are more important things to do in the project.

Here is a fitting quote to end this chapter:

#+BEGIN_QUOTE
  Although ABCs facilitate type checking, it's not something that you should overuse in a program. At its heart, Python is a dynamic language that gives you great flexibility. Trying to enforce type constraints everywhere tends to result in code that is more complicated than it needs to be. You should embrace Python's flexibility.^{[[[#ftn.id552352][86]]]}

  --- David Beazley and Brian Jones /Python Cookbook/

#+END_QUOTE

Or, as technical reviewer Leonardo Rochael wrote: “If you feel tempted to create a custom ABC, please first try to solve your problem through regular duck-typing.”

** Further Reading


Beazley and Jones's /[[http://shop.oreilly.com/product/0636920027072.do][Python Cookbook, 3rd Edition]]/ (O'Reilly) has a section about defining an ABC (Recipe 8.12). The book was written before Python 3.4, so they don't use the now preferred syntax when declaring ABCs by subclassing from =abc.ABC= instead of using the =metaclass= keyword. Apart from this small detail, the recipe covers the major ABC features very well, and ends with the valuable advice quoted at the end of the previous section.

/The Python Standard Library by Example/ by Doug Hellmann (Addison-Wesley), has a chapter about the =abc= module. It's also available on the Web in Doug's excellent [[http://pymotw.com/2/abc/index.html][PyMOTW --- Python Module of the Week]]. Both the book and the site focus on Python 2; therefore, adjustments must be made if you are using Python 3. And for Python 3.4, remember that the only recommended ABC method decorator is =@abstractmethod=---the others were deprecated. The other quote about ABCs in the chapter summary is from Doug's site and book.

When using ABCs, multiple inheritance is not only common but practically inevitable, because each of the fundamental collection ABCs---=Sequence=, =Mapping=, and =Set=---extends multiple ABCs (see [[file:ch11.html#collections_uml][Figure 11-3]]). Therefore, [[file:ch12.html][Chapter 12]] is an important follow-up to this one.

[[https://www.python.org/dev/peps/pep-3119][PEP 3119 --- Introducing Abstract Base Classes]] gives the rationale for ABCs, and [[https://www.python.org/dev/peps/pep-3141][PEP 3141 - A Type Hierarchy for Numbers]] presents the ABCs of the [[https://docs.python.org/3/library/numbers.html][=numbers= module]].

For a discussion of the pros and cons of dynamic typing, see Guido van Rossum's interview to Bill Venners in [[http://www.artima.com/intv/pycontract.html][“Contracts in Python: A Conversation with Guido van Rossum, Part IV”]].

The [[http://docs.zope.org/zope.interface/][=zope.interface=]] package provides a way of declaring interfaces, checking whether objects implement them, registering providers, and querying for providers of a given interface. The package started as a core piece of Zope 3, but it can and has been used outside of Zope. It is the basis of the flexible component architecture of large-scale Python projects like Twisted, Pyramid, and Plone. Lennart Regebro has a great introduction to =zope.interface= in [[http://bit.ly/1QOHa6x][“A Python Component Architecture”]]. Baiju M wrote an entire book about it: [[http://muthukadan.net/docs/zca.html][/A Comprehensive Guide to Zope Component Architecture/]].



Soapbox

*Type Hints*

Probably the biggest news in the Python world in 2014 was that Guido van Rossum gave a green light to the implementation of optional static type checking using function annotations, similar to what the [[http://www.mypy-lang.org/][Mypy]] checker does. This happened in the Python-ideas mailing-list on August 15. The message is [[http://bit.ly/1QOHhyX][Optional static typing --- the crossroads]]. The next month, [[https://www.python.org/dev/peps/pep-0484/][PEP 484 - Type Hints]] was published as a draft, authored by Guido.

The idea is to let programmers optionally use annotations to declare parameter and return types in function definitions. The key word here is /optionally/. You'd only add such annotations if you want the benefits and constraints that come with them, and you could put them in some functions but not in others.

On the surface, this may sound like what Microsoft did with with TypeScript, its JavaScript superset, except that TypeScript goes much further: it adds new language constructs (e.g., modules, classes, explicit interfaces, etc.), allows typed variable declarations, and actually compiles down to plain JavaScript. As of this writing, the goals of optional static typing in Python are much less ambitious.

To understand the reach of this proposal, there is a key point that Guido makes in the historic August 15, 2014, email:

#+BEGIN_QUOTE
  I am going to make one additional assumption: the main use cases will be linting, IDEs, and doc generation. These all have one thing in common: it should be possible to run a program even though it fails to type check. Also, adding types to a program should not hinder its performance (nor will it help :-).
#+END_QUOTE

So, it seems this is not such a radical move as it seems at first. [[https://www.python.org/dev/peps/pep-0482/][PEP 482 - Literature Overview for Type Hints]] is referenced by [[https://www.python.org/dev/peps/pep-0484/][PEP 484 - Type Hints]], and briefly documents type hints in third-party Python tools and in other languages.

Radical or not, type hints are upon us: support for PEP 484 in the form of a =typing= module is likely to land in Python 3.5 already. The way the proposal is worded and implemented makes it clear that no existing code will stop running because of the lack of type hints---or their addition, for that matter.

Finally, PEP 484 clearly states:

#+BEGIN_QUOTE
  It should also be emphasized that Python will remain a dynamically typed language, and the authors have no desire to ever make type hints mandatory, even by convention.
#+END_QUOTE

*Is Python Weakly Typed?*

Discussions about language typing disciplines are sometimes confused due to lack of a uniform terminology. Some writers (like Bill Venners in the interview with Guido mentioned in [[file:ch11.html#interfaces_further_reading][Further Reading]]), say that Python has weak typing, which puts it into the same category of JavaScript and PHP. A better way of talking about typing discipline is to consider two different axes:

-  Strong versus weak typing  :: If the language rarely performs implicit conversion of types, it's considered strongly typed; if it often does it, it's weakly typed. Java, C++, and Python are strongly typed. PHP, JavaScript, and Perl are weakly typed.
-  Static versus dynamic typing  :: If type-checking is performed at compile time, the language is statically typed; if it happens at runtime, it's dynamically typed. Static typing requires type declarations (some modern languages use type inference to avoid some of that). Fortran and Lisp are the two oldest programming languages still alive and they use, respectively, static and dynamic typing.

Strong typing helps catch bugs early.

Here are some examples of why weak typing is bad:^{[[[#ftn.id1010582][87]]]}

#+BEGIN_EXAMPLE
    // this is JavaScript (tested with Node.js v0.10.33)
    '' == '0'   // false
    0 == ''     // true
    0 == '0'    // true
    '' < 0      // false
    '' < '0'    // true
#+END_EXAMPLE

Python does not perform automatic coercion between strings and numbers, so the ==== expressions all result =False=---preserving the transitivity of ====---and the =<= comparisons raise =TypeError= in Python 3.

Static typing makes it easier for tools (compilers, IDEs) to analyze code to detect errors and provide other services (optimization, refactoring, etc.). Dynamic typing increases opportunities for reuse, reducing line count, and allows interfaces to emerge naturally as protocols, instead of being imposed early on.

To summarize, Python uses dynamic and strong typing. [[https://www.python.org/dev/peps/pep-0484/][PEP 484 - Type Hints]] will not change that, but will allow API authors to add optional type annotations so that tools can perform some static type checking.

*Monkey Patching*

Monkey patching has a bad reputation. If abused, it can lead to systems that are hard to understand and maintain. The patch is usually tightly coupled with its target, making it brittle. Another problem is that two libraries that apply monkey-patches may step on each other's toes, with the second library to run destroying patches of the first.

But monkey patching can also be useful, for example, to make a class implement a protocol at runtime. The adapter design pattern solves the same problem by implementing a whole new class.

It's easy to monkey-patch Python code, but there are limitations. Unlike Ruby and JavaScript, Python does not let you monkey-patch the built-in types. I actually consider this an advantage, because you can be certain that a =str= object will always have those same methods. This limitation reduces the chance that external libraries try to apply conflicting patches.

*Interfaces in Java, Go, and Ruby*

Since C++ 2.0 (1989), abstract classes have been used to specify interfaces in that language. The designers of Java opted not to have multiple inheritance of classes, which precluded the use of abstract classes as interface specifications---because often a class needs to implement more than one interface. But they added the =interface= as a language construct, and a class can implement more than one interface---a form of multiple inheritance. Making interface definitions more explicit than ever was a great contribution of Java. With Java 8, an interface can provide method implementations, called [[https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html][Default Methods]]. With this, Java interfaces became closer to abstract classes in C++ and Python.

The Go language has a completely different approach. First of all, there is no inheritance in Go. You can define interfaces, but you don't need (and you actually can't) explicitly say that a certain type implements an interface. The compiler determines that automatically. So what they have in Go could be called “static duck typing,” in the sense that interfaces are checked at compile time but what matters is what types actually implement.

Compared to Python, it's as if, in Go, every ABC implemented the =__subclasshook__= checking function names and signatures, and you never subclassed or registered an ABC. If we wanted Python to look more like Go, we would have to perform type checks on all function arguments. Some of the infrastructure is available (recall [[file:ch05.html#func_annot_sec][Function Annotations]]). Guido has already said he thinks it's OK to use those annotations for type checking---at least in support tools. See [[file:ch05.html#soapbox_1st_class_fn][Soapbox]] in [[file:ch05.html][Chapter 5]] for more about this.

Rubyists are firm believers in duck typing, and Ruby has no formal way to declare an interface or an abstract class, except to do the same we did in Python prior to 2.6: raise =NotImplementedError= in the body of methods to make them abstract by forcing the user to subclass and implement them.

Meanwhile, I read that Yukihiro “Matz” Matsumoto, creator of Ruby, said in a keynote in September 2014 that static typing may be in the future of the language. That was at Ruby Kaigi in Japan, one of the most important Ruby conferences every year. As I write this, I haven't seen a transcript, but Godfrey Chan posted about it on his blog: [[http://brewhouse.io/blog/2014/09/19/ruby-kaigi-2014-day-2][“Ruby Kaigi 2014: Day 2”]]. From Chan's report, it seems Matz focused on function annotations. There is even mention of Python function annotations.

I wonder if function annotations would be really good without ABCs to add structure to the type system without losing flexibility. So maybe formal interfaces are also in the future of Ruby.

I believe Python ABCs, with the =register= function and =__subclasshook__=, brought formal interfaces to the language without throwing away the advantages of dynamic typing.

Perhaps the geese are poised to overtake the ducks.

*Metaphors and Idioms in Interfaces*

A metaphor fosters understanding by making constraints clear. That's the value of the words “stack” and “queue” in describing those fundamental data structures: they make clear how items can be added or removed. On the other hand, Alan Cooper writes in /About Face, 4E/ (Wiley):

#+BEGIN_QUOTE
  Strict adherence to metaphors ties interfaces unnecessarily tightly to the workings of the physical world.
#+END_QUOTE

He's referring to user interfaces, but the admonition applies to APIs as well. But Cooper does grant that when a “truly appropriate” metaphor “falls on our lap,” we can use it (he writes “falls on our lap” because it's so hard to find fitting metaphors that you should not spend time actively looking for them). I believe the bingo machine imagery I used in this chapter is appropriate and I stand by it.

/About Face/ is by far the best book about UI design I've read---and I've read a few. Letting go of metaphors as a design paradigm, and replacing it with “idiomatic interfaces” was the most valuable thing I learned from Cooper's work. As mentioned, Cooper does not deal with APIs, but the more I think about his ideas, the more I see how they apply to Python. The fundamental protocols of the language are what Cooper calls “idioms.” Once we learn what a “sequence” is we can apply that knowledge in different contexts. This is a main theme of /Fluent Python/: highlighting the fundamental idioms of the language, so your code is concise, effective, and readable---for a fluent Pythonista.



--------------


^{[[[#id495252][67]]]} Bjarne Stroustrup, /The Design and Evolution of C++/ (Addison-Wesley, 1994), p. 278.


^{[[[#id578610][68]]]} [[http://bugs.python.org/issue16518][Issue16518: “add /buffer protocol/ to glossary”]] was actually resolved by replacing many mentions of “object that supports the buffer protocol/interface/API” with “bytes-like object”; a follow-up issue is [[http://bugs.python.org/issue22581][“Other mentions of the buffer protocol”]].


^{[[[#id822796][69]]]} You can also, of course, define your own ABCs---but I would discourage all but the most advanced Pythonistas from going that route, just as I would discourage them from defining their own custom metaclasses... and even for said “most advanced Pythonistas,” those of us sporting deep mastery of every fold and crease in the language, these are not tools for frequent use: such “deep metaprogramming,” if ever appropriate, is intended for authors of broad frameworks meant to be independently extended by vast numbers of separate development teams... less than 1% of “most advanced Pythonistas” may ever need that! --- /A.M./


^{[[[#id402701][70]]]} Unfortunately, in Python 3.4, there is no ABC that helps distinguish a =str= from =tuple= or other immutable sequences, so we must test against =str=. In Python 2, the =basestr= type exists to help with tests like these. It's not an ABC, but it's a superclass of both =str= and =unicode=; however, in Python 3, =basestr= is gone. Curiously, there is in Python 3 a =collections.abc.ByteString= type, but it only helps detecting =bytes= and =bytearray=.


^{[[[#id391666][71]]]} This snippet was extracted from [[file:ch21.html#record_factory_ex][Example 21-2]].


^{[[[#id672780][72]]]} Multiple inheritance was /considered harmful/ and excluded from Java, except for interfaces: Java interfaces can extend multiple interfaces, and Java classes can implement multiple interfaces.


^{[[[#id479746][73]]]} For callable detection, there is the =callable()= built-in function---but there is no equivalent =hashable()= function, so =isinstance(my_obj, Hashable)= is the preferred way to test for a hashable object.


^{[[[#id692310][74]]]} Perhaps the client needs to audit the randomizer; or the agency wants to provide a rigged one. You never know...


^{[[[#id439702][75]]]} The Oxford English Dictionary defines tombola as “A kind of lottery resembling lotto.”


^{[[[#id996071][76]]]} «registered» and «virtual subclass» are not standard UML words. We are using them to represent a class relationship that is specific to Python.


^{[[[#id443944][77]]]} Before ABCs existed, abstract methods would use the statement =raise NotImplementedError= to signal that subclasses were responsible for their implementation.


^{[[[#id962479][78]]]} [[http://bit.ly/1QOFpGB][=@abc.abstractmethod=]] entry in the [[https://docs.python.org/dev/library/abc.html][=abc= module documentation]].


^{[[[#id995539][79]]]} I gave this as an example of duck typing after Martelli's [[file:ch11.html#waterfowl_essay][Waterfowl and ABCs]].


^{[[[#id537400][80]]]} [[file:ch08.html#defensive_argument][Defensive Programming with Mutable Parameters]] in [[file:ch08.html][Chapter 8]] was devoted to the aliasing issue we just avoided here.


^{[[[#id460979][81]]]} The same trick I used with =load= doesn't work with =loaded=, because the =list= type does not implement =__bool__=, the method I'd have to bind to =loaded=. On the other hand, the =bool= built-in function doesn't need =__bool__= to work because it can also use =__len__=. See [[https://docs.python.org/3/library/stdtypes.html#truth][“4.1. Truth Value Testing”]] in the “Built-in Types” chapter.


^{[[[#id1059229][82]]]} There is a whole section explaining the =__mro__= class attribute in [[file:ch12.html#mro_section][Multiple Inheritance and Method Resolution Order]]. Right now, this quick explanation will do.


^{[[[#id1023307][83]]]} Alex coined the expression “goose typing” and this is the first time ever it appears in a book!


^{[[[#id477114][84]]]} PyMOTW, =abc= module page, section [[http://bit.ly/1QOGle5][“Why use Abstract Base Classes?”]]


^{[[[#id907350][85]]]} You'll find that in the Python standard library too: classes that are in fact abstract but nobody ever made them explicitly so.


^{[[[#id552352][86]]]} /Python Cookbook, 3rd Edition/ (O'Reilly), “Recipe 8.12. Defining an Interface or Abstract Base Class”, p. 276.


^{[[[#id1010582][87]]]} Adapted from Douglas Crockford's /JavaScript: The Good Parts/ (O'Reilly), Appendix B, p. 109.


the statement =raise NotImplementedError= to signal that subclasses were responsible for their implementation.


^{[[[#id962479][78]]]} [[http://bit.ly/1QOFpGB][=@abc.abstractmethod=]] entry in the [[https://docs.python.org/dev/library/abc.html][=abc= module documentation]].


^{[[[#id995539][79]]]} I gave this as an example of duck typing after Martelli's [[file:ch11.html#waterfowl_essay][Waterfowl and ABCs]].


^{[[[#id537400][80]]]} [[file:ch08.html#defensive_argument][Defensive Programming with Mutable Parameters]] in [[file:ch08.html][Chapter 8]] was devoted to the aliasing issue we just avoided here.


^{[[[#id460979][81]]]} The same trick I used with =load= doesn't work with =loaded=, because the =list= type does not implement =__bool__=, the method I'd have to bind to =loaded=. On the other hand, the =bool= built-in function doesn't need =__bool__= to work because it can also use =__len__=. See [[https://docs.python.org/3/library/stdtypes.html#truth][“4.1. Truth Value Testing”]] in the “Built-in Types” chapter.


^{[[[#id1059229][82]]]} There is a whole section explaining the =__mro__= class attribute in [[file:ch12.html#mro_section][Multiple Inheritance and Method Resolution Order]]. Right now, this quick explanation will do.


^{[[[#id1023307][83]]]} Alex coined the expression “goose typing” and this is the first time ever it appears in a book!


^{[[[#id477114][84]]]} PyMOTW, =abc= module page, section [[http://bit.ly/1QOGle5][“Why use Abstract Base Classes?”]]


^{[[[#id907350][85]]]} You'll find that in the Python standard library too: classes that are in fact abstract but nobody ever made them explicitly so.


^{[[[#id552352][86]]]} /Python Cookbook, 3rd Edition/ (O'Reilly), “Recipe 8.12. Defining an Interface or Abstract Base Class”, p. 276.


^{[[[#id1010582][87]]]} Adapted from Douglas Crockford's /JavaScript: The Good Parts/ (O'Reilly), Appendix B, p. 109.


 Base Class”, p. 276.

<<ftn.id1010582>>
^{[[[#id1010582][87]]]} Adapted from Douglas Crockford's /JavaScript: The Good Parts/ (O'Reilly), Appendix B, p. 109.


